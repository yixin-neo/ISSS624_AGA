---
title: "Hands-on Exercise 2.1: Spatial Weights and Applications"
author: "NeoYX"
date: '20 Nov 2023'
date-modified: "`r Sys.Date()`"
editor: visual
execute: 
  freeze: auto
  warning: false
  #echo: false
  #message: false
format: 
  html:
    code-fold: false
    code-overflow: scroll
    code-summary: "Show the code"
    code-line-numbers: true
---

## **8.1 Overview**

In this hands-on exercise, we will learn how to compute spatial weights using R. By the end to this hands-on exercise, we will be able to:

-   import geospatial data using appropriate function(s) of **sf** package,

-   import csv file using appropriate function of **readr** package,

-   perform relational join using appropriate join function of **dplyr** package,

-   compute spatial weights using appropriate functions of **spdep** package, and

-   calculate spatially lagged variables using appropriate functions of **spdep** package.

## **8.2 The Study Area and Data**

Two data sets will be used in this hands-on exercise, they are:

-   Hunan county boundary layer. This is a geospatial data set in ESRI shapefile format.

-   Hunan_2012.csv: This csv file (aspatial) contains selected Hunan's local development indicators in 2012.

### **8.2.1 Getting Started**

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)
```

## **8.3 Getting the Data Into R Environment**

**8.3.1 Import shapefile into r environment**

The code chunk below uses [*st_read()*](https://r-spatial.github.io/sf/reference/st_read.html) of **sf** package to import Hunan shapefile into R. The imported shapefile will be **simple features** Object of **sf**.

```{r}
hunan <- st_read(dsn='data/geospatial',
                 layer = 'Hunan')
class(hunan)
```

`hunan` is in WSG84 coordinate system.

```{r}
head(hunan,3) %>% kable()
```

### **8.3.2 Import csv file into r environment**

Next, we will import *Hunan_2012.csv* into R by using *read_csv()* of **readr** package. The output is R dataframe class.

```{r}
hunan2012 <- read_csv('data/aspatial/Hunan_2012.csv')
head(hunan2012,3) %>% kable()
```

### **8.3.3 Performing relational join**

The code chunk below will be used to update the attribute table of *hunan*'s SpatialPolygonsDataFrame with the attribute fields of *hunan2012* dataframe. This is performed by using *left_join()* of **dplyr** package.

As the join columns are not specified, this function will assume that columns with the same names, e.g., 'county' in both dfs will be the join columns.

The select() will retain the columns indicated in the resulting joined df.

```{r}
hunan <- left_join(hunan, hunan2012) %>% 
  select(1:4,7,15)
class(hunan)
```

Note the geospatial characteristics of hunan is retained.

```{r}
head(hunan,3) %>% kable
```

## **8.4 Visualising Regional Development Indicator**

Now, we are going to prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using *qtm()* of **tmap** package.

```{r}
#| fig-width: 14
#| fig-asp: 0.68
basemap <- tm_shape(hunan)+
  tm_polygons() +
  tm_text('NAME_3',
          size = 0.35)

gdppc <- tm_shape(hunan)+
  tm_polygons('GDPPC') +
    tm_layout(legend.height = 0.20, 
            legend.width = 0.25)
  

tmap_arrange(basemap, gdppc,
           asp=1,
           ncol=2)
```

## **8.5 Computing Contiguity Spatial Weights**

In this section, we will use [*poly2nb()*](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package to compute contiguity weight matrices for the study area. This function builds a neighbours list based on regions with contiguous boundaries.

By default, 'queen' argument is set to TRUE: two polygons sharing one shared boundary point will meet contiguity condition. Returns a list of first order neighbours using the Queen criteria.

If 'queen' argument is set to FALSE: requires more than one shared boundary point. (but may not mean a shared boundary line)

### **8.5.1 Computing (QUEEN) contiguity based neighbours**

The code chunk below is used to compute Queen contiguity weight matrix.

```{r}
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```

The summary report above shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours. There are two area units with only one heighbours.

`wm_q` (weights matrix queen) 's class

```{r}
class(wm_q)
```

A quick peak at `wm_q`

```{r}
head(wm_q,3)
```

For each polygon in our polygon object, *wm_q* lists all neighboring polygons. For example, to see the neighbors for the first polygon in the object, type:

```{r}
wm_q[[1]]
```

Polygon 1 has 5 neighbors. The numbers represent the polygon IDs as stored in hunan SpatialPolygonsDataFrame class.

We can retrive the county name of Polygon ID=1 by using the code chunk below:

```{r}
hunan$County[1]
```

Polygon ID=1 is Anxiang county.

To reveal the county names of the five neighboring polygons, the code chunk will be used:

```{r}
x1 <- wm_q[[1]]
hunan$County[c(x1)]
```

The printed output above shows that the GDPPC of the five nearest neighbours based on Queen\'s method are 20981, 34592, 24473, 21311 and 22879 respectively.

To display the complete weight matrix, use *str()*

```{r}
str(wm_q)
#wm_q[1:10]
#methods(class = class(wm_q))

```

### **8.5.2 Creating (ROOK) contiguity based neighbours**

The code chunk below is used to compute Rook contiguity weight matrix.

```{r}
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)
```

The summary report above shows that there are 88 area units in Hunan. The most connect area unit has 10 neighbours. There are two area units with only one heighbours.








```{r}
#| code-fold: True
#| eval: false
#| echo: false
#| fig-width: 14
#| fig-asp: 0.68
```

## Theories

### 
