[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_1.html",
    "href": "Hands-on_Ex1/Hands-on_Ex1_1.html",
    "title": "Hands-on Exercise 1.1: Geospatial Data Wrangling with R",
    "section": "",
    "text": "In this hands-on exercise, I will learn how to import and wrangle geospatial data using appropriate R packages:\n\ninstalling and loading sf and tidyverse packages into R environment,\nimporting geospatial data by using appropriate functions of sf package,\nimporting aspatial data by using appropriate function of readr package,\nexploring the content of simple feature data frame by using appropriate Base R and sf functions,\nassigning or transforming coordinate systems by using appropriate sf functions,\nconverting an aspatial data into a sf data frame by using appropriate function of sf package,\nperforming geoprocessing tasks by using appropriate functions of sf package,\nperforming data wrangling tasks by using appropriate functions of dplyr package and\nperforming Exploratory Data Analysis (EDA) by using appropriate functions from ggplot2 package."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_1.html#data-acquisition",
    "href": "Hands-on_Ex1/Hands-on_Ex1_1.html#data-acquisition",
    "title": "Hands-on Exercise 1.1: Geospatial Data Wrangling with R",
    "section": "1.2 Data Acquisition",
    "text": "1.2 Data Acquisition\nIn this hands-on exercise, data is acquired from the following sources:\n\nMaster Plan 2014 Subzone Boundary (Web) from data.gov.sg\nPre-Schools Location from data.gov.sg\nCycling Path from LTADataMall\nLatest version of Singapore Airbnb listing data from Inside Airbnb"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_1.html#getting-started",
    "href": "Hands-on_Ex1/Hands-on_Ex1_1.html#getting-started",
    "title": "Hands-on Exercise 1.1: Geospatial Data Wrangling with R",
    "section": "1.3 Getting Started",
    "text": "1.3 Getting Started\nThe code chunk below install and load sf and tidyverse packages into R environment:\n\npacman::p_load(sf, tidyverse)\n\n\nsf for importing, managing, and processing geospatial data, and\ntidyverse for performing data science tasks such as importing, wrangling and visualising data.\n\nThe sp package provides classes and methods for spatial data types in 2005. The sf package was released in 2016 to give standardise support for vector data in R. It is also coherent with tidyverse, that consists of the following (not exhaustive):\n\nreadr for importing csv data,\nreadxl for importing Excel worksheet,\ntidyr for manipulating data,\ndplyr for transforming data, and\nggplot2 for visualising data"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_1.html#importing-geospatial-data",
    "href": "Hands-on_Ex1/Hands-on_Ex1_1.html#importing-geospatial-data",
    "title": "Hands-on Exercise 1.1: Geospatial Data Wrangling with R",
    "section": "1.4 Importing Geospatial data",
    "text": "1.4 Importing Geospatial data\nThe data that we will be importing takes the following forms:\n\nMP14_SUBZONE_WEB_PL, a polygon feature layer in ESRI shapefile format,\nCyclingPath, a line feature layer in ESRI shapefile format, and\nPreSchool, a point feature layer in kml file format.\n\n\n1.4.1 Importing polygon feature data in shapefile format\nst_read() is a func from sf package, used to read files in shapefile format.\ndsn- data source name (aka data path)\nlayer - shapefile name. No extensions like .shp, .dbf, .prj and .shx are needed.\n\nmpsz <- st_read(dsn=\"data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\yixin-neo\\ISSS624_AGA\\Hands-on_Ex1\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\ngeospatial objects are multipolygon features\ntotal of 323 multipolygon features and 15 fields in mpsz simple feature data frame.\nmpsz is in svy21 projected coordinates systems\nx extend and y extend of the data are given\n\n\nlibrary(knitr)\nkable(head(mpsz, n = 3))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOBJECTID\nSUBZONE_NO\nSUBZONE_N\nSUBZONE_C\nCA_IND\nPLN_AREA_N\nPLN_AREA_C\nREGION_N\nREGION_C\nINC_CRC\nFMEL_UPD_D\nX_ADDR\nY_ADDR\nSHAPE_Leng\nSHAPE_Area\ngeometry\n\n\n\n\n1\n1\nMARINA SOUTH\nMSSZ01\nY\nMARINA SOUTH\nMS\nCENTRAL REGION\nCR\n5ED7EB253F99252E\n2014-12-05\n31595.84\n29220.19\n5267.381\n1630379.3\nMULTIPOLYGON (((31495.56 30…\n\n\n2\n1\nPEARL’S HILL\nOTSZ01\nY\nOUTRAM\nOT\nCENTRAL REGION\nCR\n8C7149B9EB32EEFC\n2014-12-05\n28679.06\n29782.05\n3506.107\n559816.2\nMULTIPOLYGON (((29092.28 30…\n\n\n3\n3\nBOAT QUAY\nSRSZ03\nY\nSINGAPORE RIVER\nSR\nCENTRAL REGION\nCR\nC35FEFF02B13E0E5\n2014-12-05\n29654.96\n29974.66\n1740.926\n160807.5\nMULTIPOLYGON (((29932.33 29…\n\n\n\n\n\n\n\n1.4.2 Importing polyline feature data in shapefile form\nThe code chunk below uses st_read() function of sf package to import CyclingPath shapefile into R as line feature data frame.\n\ncyclingpath = st_read(dsn='data/geospatial', layer='CyclingPathGazette')\n\nReading layer `CyclingPathGazette' from data source \n  `C:\\yixin-neo\\ISSS624_AGA\\Hands-on_Ex1\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 2248 features and 2 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 11854.32 ymin: 28347.98 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\n\nkable(head(cyclingpath, n = 3))\n\n\n\n\nPLANNING_A\nPLANNING_1\ngeometry\n\n\n\n\nNA\nNA\nMULTILINESTRING ((16001.13 …\n\n\nNA\nNA\nMULTILINESTRING ((16012.86 …\n\n\nNA\nNA\nMULTILINESTRING ((16021.49 …\n\n\n\n\n\n\n\n1.4.3 Importing GIS data in kml format\nThe pre-schools-location-kml is in kml format.\n\npreschool = st_read('data/geospatial/pre-schools-location-kml.kml')\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `C:\\yixin-neo\\ISSS624_AGA\\Hands-on_Ex1\\data\\geospatial\\pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1925 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\nNote that preschool is in WSG84 coordinates system (3D).\n\nkable(head(preschool, n = 3))\n\n\n\n\n\n\n\n\n\nName\nDescription\ngeometry\n\n\n\n\nkml_1\n\nPOINT Z (103.7009 1.338325 0)\n\n\nkml_2\n\nPOINT Z (103.8987 1.39044 0)\n\n\nkml_3\n\nPOINT Z (103.8068 1.438017 0)\n\n\n\n\n\n\n\n1.5.1 Working with st_geometry()\nThe column in the sf data.frame that contains the geometries is a list, of class sfc. We can retrieve the geometry list-column in this case by mpsz$geom or mpsz[[1]], but the more general way uses st_geometry() as shown in the code chunk below.\n\nclass(mpsz)\n\n[1] \"sf\"         \"data.frame\"\n\n\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\n\n\n1.5.2 Working with glimpse()\nBeside the basic feature information, we also would like to learn more about the associated attribute information in the data frame. This is the time you will find glimpse() of dplyr. very handy as shown in the code chunk below.\n\nglimpse(head(mpsz))\n\nRows: 6\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\"\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\"\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\"\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\"\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05,…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913\n$ SHAPE_Area <dbl> 1630379.3, 559816.2, 160807.5, 595428.9, 387429.4, 1030378.8\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (((29092.28 30…\n\n\nglimpse() report reveals the data type of each fields. For example FMEL-UPD_D field is in date data type and X_ADDR, Y_ADDR, SHAPE_L and SHAPE_AREA fields are all in double-precision values.\n\n\n1.5.3 Working with head()\nSometimes we would like to reveal complete information of a feature object, this is the job of head() of Base R\n\nhead(mpsz,3)\n\nSimple feature collection with 3 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 28160.23 ymin: 28369.47 xmax: 32362.39 ymax: 30247.18\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO    SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N PLN_AREA_C\n1        1          1 MARINA SOUTH    MSSZ01      Y    MARINA SOUTH         MS\n2        2          1 PEARL'S HILL    OTSZ01      Y          OUTRAM         OT\n3        3          3    BOAT QUAY    SRSZ03      Y SINGAPORE RIVER         SR\n        REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR\n1 CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84 29220.19\n2 CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06 29782.05\n3 CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96 29974.66\n  SHAPE_Leng SHAPE_Area                       geometry\n1   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3   1740.926   160807.5 MULTIPOLYGON (((29932.33 29..."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_1.html#plotting-the-geospatial-data",
    "href": "Hands-on_Ex1/Hands-on_Ex1_1.html#plotting-the-geospatial-data",
    "title": "Hands-on Exercise 1.1: Geospatial Data Wrangling with R",
    "section": "1.6 Plotting the Geospatial Data",
    "text": "1.6 Plotting the Geospatial Data\nIn geospatial data science, by looking at the feature information is not enough. We are also interested to visualise the geospatial features. One of the ways is to use the plot() of R Graphic.\n\nplot(mpsz)\n\n\n\n\nThe default plot of an sf object is a multi-plot of all attributes, up to a reasonable maximum as shown above. We can, however, choose to plot only the geometry (multi-polygon) by using the code chunk below.\n\nplot(st_geometry(mpsz))\n\n\n\n\nAlternatively, we can also choose the plot the sf object by using a specific attribute as shown in the code chunk below.\n\nplot(mpsz[\"REGION_N\"])\n\n\n\n\n\n\n\n\n\n\nNote: plot() is mean for plotting the geospatial object for quick look. For high cartographic quality plot, other R package such as tmap should be used."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_1.html#working-with-projection",
    "href": "Hands-on_Ex1/Hands-on_Ex1_1.html#working-with-projection",
    "title": "Hands-on Exercise 1.1: Geospatial Data Wrangling with R",
    "section": "1.7 Working with Projection",
    "text": "1.7 Working with Projection\nMap projection is an important property of a geospatial data. In order to perform geoprocessing using two geospatial data, we need to ensure that both geospatial data are projected using similar coordinate system.\nIn this section, you will learn how to project a simple feature data frame from one coordinate system to another coordinate system. The technical term of this process is called projection transformation.\n\n1.7.1 Assigning EPSG code to a simple feature data frame\nCommon issues:\n\ncoordinate system of the source data was missing (such as due to missing .proj for ESRI shapefile)\nwrongly assigned during the importing process\n\nUsing the st_crs() to check in detail of the mpszreveals that although it claims to be in svy21 (singapore proj sys), reading until end of print shows that it is wrongly in EPSG9001 (singapore uses epsg3414)\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\nIn order to assign the correct EPSG code to mpsz data frame, st_set_crs() of sf package is used as shown in the code chunk below.\n\nmpsz3414 <- st_transform(mpsz, 3414)\n\nRecheck\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\nNotice that the EPSG code is 3414 now.\n\n\n1.7.2 Transforming the projection of preschool from wgs84 to svy21 (EPSG3414).\nIn geospatial analytics, it is very common for us to transform the original data from geographic coordinate system (3D) to projected coordinate system (2D). This is because geographic coordinate system is not appropriate if the analysis need to use distance or/and area measurements.\nLet us take preschool simple feature data frame as an example. The print below reveals that it is in wgs84 coordinate system (3D).\n\nst_geometry(preschool)\n\nGeometry set for 1925 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\n\nst_crs(preschool)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\n\nNote that st_set_crs() is not appropriate and st_transform() of sf package should be used. This is because we need to reproject preschool from one coordinate system to another coordinate system mathemetically.\nLet us perform the projection transformation by using the code chunk below.\n\npreschool3414 <- st_transform(preschool, crs=3414)\n\nRecheck\n\n\nGeometry set for 1925 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 11203.01 ymin: 25596.33 xmax: 45404.24 ymax: 49300.88\nz_range:       zmin: 0 zmax: 0\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n\n\nNotice that it is in svy21 projected coordinate system now. Furthermore, if we refer to Bounding box:, the values are greater than 0-360 range of decimal degree commonly used by most of the geographic coordinate systems."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_1.html#importing-and-converting-an-aspatial-data",
    "href": "Hands-on_Ex1/Hands-on_Ex1_1.html#importing-and-converting-an-aspatial-data",
    "title": "Hands-on Exercise 1.1: Geospatial Data Wrangling with R",
    "section": "1.8 Importing and Converting An Aspatial Data",
    "text": "1.8 Importing and Converting An Aspatial Data\nIn practice, it is not unusual that we will come across data such as listing of Inside Airbnb. We call this kind of data aspatial data. This is because it is not a geospatial data but among the data fields, there are two fields that capture the x- (long) and y-coordinates (lat) of the data points.\nIn this section, we will learn how to\n\nimport an aspatial data into R environment and save it as a tibble data frame\nconvert it into a simple feature data frame.\n\nThe listings.csv data downloaded from AirBnb will be used.\n\n1.8.1 Importing the aspatial data\nSince listings data set is in csv file format, we will use read_csv() of readr package to import listing.csv as shown the code chunk below. The output R object is called listings and it is a tibble data frame.\n\nlistings <- read_csv('data/aspatial/listings.csv')\nclass(listings)\n\n[1] \"spec_tbl_df\" \"tbl_df\"      \"tbl\"         \"data.frame\" \n\n\nAfter importing the data file into R, it is important for us to examine if the data file has been imported correctly.\nThe code chunk below shows list() of Base R instead of glimpse() is used to do the job.\n\nlist(listings)\n\n[[1]]\n# A tibble: 4,161 × 18\n       id name      host_id host_name neighbourhood_group neighbourhood latitude\n    <dbl> <chr>       <dbl> <chr>     <chr>               <chr>            <dbl>\n 1  50646 Pleasant…  227796 Sujatha   Central Region      Bukit Timah       1.33\n 2  71609 Ensuite …  367042 Belinda   East Region         Tampines          1.35\n 3  71896 B&B  Roo…  367042 Belinda   East Region         Tampines          1.35\n 4  71903 Room 2-n…  367042 Belinda   East Region         Tampines          1.35\n 5 275344 15 mins … 1439258 Kay       Central Region      Bukit Merah       1.29\n 6 289234 Booking …  367042 Belinda   East Region         Tampines          1.34\n 7 294281 5 mins w… 1521514 Elizabeth Central Region      Newton            1.31\n 8 324945 Cozy Blu… 1439258 Kay       Central Region      Bukit Merah       1.29\n 9 330089 Cozy Blu… 1439258 Kay       Central Region      Bukit Merah       1.29\n10 330095 10 mins … 1439258 Kay       Central Region      Bukit Merah       1.29\n# ℹ 4,151 more rows\n# ℹ 11 more variables: longitude <dbl>, room_type <chr>, price <dbl>,\n#   minimum_nights <dbl>, number_of_reviews <dbl>, last_review <date>,\n#   reviews_per_month <dbl>, calculated_host_listings_count <dbl>,\n#   availability_365 <dbl>, number_of_reviews_ltm <dbl>, license <chr>\n\n\nOther ways of displaying tabular data in R:\n\nkablegtDT (interactive table)\n\n\n\nkable(head(listings))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nid\nname\nhost_id\nhost_name\nneighbourhood_group\nneighbourhood\nlatitude\nlongitude\nroom_type\nprice\nminimum_nights\nnumber_of_reviews\nlast_review\nreviews_per_month\ncalculated_host_listings_count\navailability_365\nnumber_of_reviews_ltm\nlicense\n\n\n\n\n50646\nPleasant Room along Bukit Timah\n227796\nSujatha\nCentral Region\nBukit Timah\n1.33432\n103.7852\nPrivate room\n80\n92\n18\n2014-12-26\n0.18\n1\n365\n0\nNA\n\n\n71609\nEnsuite Room (Room 1 & 2) near EXPO\n367042\nBelinda\nEast Region\nTampines\n1.34537\n103.9589\nPrivate room\n145\n92\n20\n2020-01-17\n0.15\n6\n340\n0\nNA\n\n\n71896\nB&B Room 1 near Airport & EXPO\n367042\nBelinda\nEast Region\nTampines\n1.34754\n103.9596\nPrivate room\n85\n92\n24\n2019-10-13\n0.18\n6\n265\n0\nNA\n\n\n71903\nRoom 2-near Airport & EXPO\n367042\nBelinda\nEast Region\nTampines\n1.34531\n103.9610\nPrivate room\n85\n92\n47\n2020-01-09\n0.34\n6\n365\n0\nNA\n\n\n275344\n15 mins to Outram MRT Single Room\n1439258\nKay\nCentral Region\nBukit Merah\n1.28836\n103.8114\nPrivate room\n49\n60\n14\n2022-07-09\n0.11\n44\n296\n1\nS0399\n\n\n289234\nBooking for 3 bedrooms\n367042\nBelinda\nEast Region\nTampines\n1.34490\n103.9598\nPrivate room\n184\n92\n12\n2019-01-01\n0.10\n6\n285\n0\nNA\n\n\n\n\n\n\n\n\nlibrary(gt)\nhead(listings) %>% gt() %>% tab_header(title = \"AirBnB listings\")\n\n\n\n\n\n  \n    \n      AirBnB listings\n    \n    \n    \n      id\n      name\n      host_id\n      host_name\n      neighbourhood_group\n      neighbourhood\n      latitude\n      longitude\n      room_type\n      price\n      minimum_nights\n      number_of_reviews\n      last_review\n      reviews_per_month\n      calculated_host_listings_count\n      availability_365\n      number_of_reviews_ltm\n      license\n    \n  \n  \n    50646\nPleasant Room along Bukit Timah\n227796\nSujatha\nCentral Region\nBukit Timah\n1.33432\n103.7852\nPrivate room\n80\n92\n18\n2014-12-26\n0.18\n1\n365\n0\nNA\n    71609\nEnsuite Room (Room 1 & 2) near EXPO\n367042\nBelinda\nEast Region\nTampines\n1.34537\n103.9589\nPrivate room\n145\n92\n20\n2020-01-17\n0.15\n6\n340\n0\nNA\n    71896\nB&B  Room 1 near Airport & EXPO\n367042\nBelinda\nEast Region\nTampines\n1.34754\n103.9596\nPrivate room\n85\n92\n24\n2019-10-13\n0.18\n6\n265\n0\nNA\n    71903\nRoom 2-near Airport & EXPO\n367042\nBelinda\nEast Region\nTampines\n1.34531\n103.9610\nPrivate room\n85\n92\n47\n2020-01-09\n0.34\n6\n365\n0\nNA\n    275344\n15 mins to Outram MRT Single Room\n1439258\nKay\nCentral Region\nBukit Merah\n1.28836\n103.8114\nPrivate room\n49\n60\n14\n2022-07-09\n0.11\n44\n296\n1\nS0399\n    289234\nBooking for 3 bedrooms\n367042\nBelinda\nEast Region\nTampines\n1.34490\n103.9598\nPrivate room\n184\n92\n12\n2019-01-01\n0.10\n6\n285\n0\nNA\n  \n  \n  \n\n\n\n\n\n\n\nlibrary(DT)\ndatatable(head(listings), class = 'cell-border stripe', options = list(pageLength = 3))\n\n\n\n\nTwo useful fields we need are latitude and longitude and they are in decimal degree format. As a best guess, we will assume that the data is in wgs84 Geographic Coordinate System.\n\n\n1.8.2 Creating a simple feature data frame from an aspatial data frame\nThe code chunk below converts listing data frame into a simple feature data frame by using st_as_sf() of sf packages.\nEPSG 4326 is associated with WGS84.\n\nlistings_sf <- st_as_sf(listings,\n                        coords = c('longitude','latitude'),\n                        crs=4326) %>%\n  st_transform(crs=3414)\n\nclass(listings_sf)\n\n[1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\nThings to learn from the arguments above:\n\ncoords argument requires you to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.\ncrs argument requires you to provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. You can search for other country’s epsg code by referring to epsg.io.\n\nLet us examine the content of our newly created sf dataframe\n\nglimpse(listings_sf)\n\nRows: 4,161\nColumns: 17\n$ id                             <dbl> 50646, 71609, 71896, 71903, 275344, 289…\n$ name                           <chr> \"Pleasant Room along Bukit Timah\", \"Ens…\n$ host_id                        <dbl> 227796, 367042, 367042, 367042, 1439258…\n$ host_name                      <chr> \"Sujatha\", \"Belinda\", \"Belinda\", \"Belin…\n$ neighbourhood_group            <chr> \"Central Region\", \"East Region\", \"East …\n$ neighbourhood                  <chr> \"Bukit Timah\", \"Tampines\", \"Tampines\", …\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat…\n$ price                          <dbl> 80, 145, 85, 85, 49, 184, 79, 49, 55, 5…\n$ minimum_nights                 <dbl> 92, 92, 92, 92, 60, 92, 92, 60, 60, 60,…\n$ number_of_reviews              <dbl> 18, 20, 24, 47, 14, 12, 133, 17, 12, 3,…\n$ last_review                    <date> 2014-12-26, 2020-01-17, 2019-10-13, 20…\n$ reviews_per_month              <dbl> 0.18, 0.15, 0.18, 0.34, 0.11, 0.10, 1.0…\n$ calculated_host_listings_count <dbl> 1, 6, 6, 6, 44, 6, 7, 44, 44, 44, 6, 7,…\n$ availability_365               <dbl> 365, 340, 265, 365, 296, 285, 365, 181,…\n$ number_of_reviews_ltm          <dbl> 0, 0, 0, 0, 1, 0, 0, 3, 2, 0, 1, 0, 0, …\n$ license                        <chr> NA, NA, NA, NA, \"S0399\", NA, NA, \"S0399…\n$ geometry                       <POINT [m]> POINT (22646.02 35167.9), POINT (…\n\n\nA new column geometry has been added at the back of the df. Additionally, lat long columns were both dropped from the df."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_1.html#geoprocessing-with-sf-package",
    "href": "Hands-on_Ex1/Hands-on_Ex1_1.html#geoprocessing-with-sf-package",
    "title": "Hands-on Exercise 1.1: Geospatial Data Wrangling with R",
    "section": "1.9 Geoprocessing with sf package",
    "text": "1.9 Geoprocessing with sf package\nBesides providing functions to handling (i.e. importing, exporting, assigning projection, transforming projection etc) geospatial data, sf package also offers a wide range of geoprocessing (also known as GIS analysis) functions.\nIn this section, we will learn how to perform two commonly used geoprocessing functions, namely buffering and point in polygon count.\n\n1.9.1 Buffering\nThe scenario:\nThe authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. You are tasked to determine the extend of the land need to be acquired and their total area.\nThe solution:\nA buffer is a zone around a spatial object, recall that cyclingpath is a multiline-string sf object.\n\nst_geometry(cyclingpath)\n\nGeometry set for 2248 features \nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 11854.32 ymin: 28347.98 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nFirstly, st_buffer() of sf package is used to compute the 5-meter buffers around cyclingpath .\n\nbuffer_cycling <- st_buffer(cyclingpath,\n                            dist = 5,\n                            nQuadSegs = 30)\n\nTake a peak at this df before calculating area.\n\nhead(buffer_cycling)\n\nSimple feature collection with 6 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 15867.37 ymin: 36795.67 xmax: 16026.95 ymax: 36953.73\nProjected CRS: SVY21\n  PLANNING_A PLANNING_1                       geometry\n1       <NA>       <NA> POLYGON ((16004.15 36799.78...\n2       <NA>       <NA> POLYGON ((16013.15 36849.86...\n3       <NA>       <NA> POLYGON ((16016.91 36892.98...\n4       <NA>       <NA> POLYGON ((16017.59 36864, 1...\n5       <NA>       <NA> POLYGON ((16022.36 36900.57...\n6       <NA>       <NA> POLYGON ((15903.87 36941.12...\n\n\nNow, we will calculate the area of the buffers as shown in the code chunk below.\nWe are also adding a derived column to buffer_cycling too.\n\nbuffer_cycling$AREA <- st_area(buffer_cycling)\nkable(head(buffer_cycling))\n\n\n\n\n\n\n\n\n\n\nPLANNING_A\nPLANNING_1\ngeometry\nAREA\n\n\n\n\nNA\nNA\nPOLYGON ((16004.15 36799.78…\n186.2934 [m^2]\n\n\nNA\nNA\nPOLYGON ((16013.15 36849.86…\n293.4840 [m^2]\n\n\nNA\nNA\nPOLYGON ((16016.91 36892.98…\n284.8275 [m^2]\n\n\nNA\nNA\nPOLYGON ((16017.59 36864, 1…\n144.8915 [m^2]\n\n\nNA\nNA\nPOLYGON ((16022.36 36900.57…\n281.2016 [m^2]\n\n\nNA\nNA\nPOLYGON ((15903.87 36941.12…\n398.7081 [m^2]\n\n\n\n\n\nLastly, sum() of Base R will be used to derive the total land involved\n\nsum(buffer_cycling$AREA)\n\n1556978 [m^2]\n\n\nGood Job!\nMission Accomplished!\n\n\n1.9.2 Point-in-polygon count\nThe scenario:\nA pre-school service group want to find out the numbers of pre-schools in each Planning Subzone.\nBefore that, lets double confirm both data are using same projection system.\n\nidentical(st_crs(mpsz3414), st_crs(preschool3414))\n\n[1] TRUE\n\n\nThe solution:\nThe code chunk below performs two operations at one go.\n\nidentify pre-schools located inside each Planning Subzone by using st_intersects().\nlength() of Base R is used to calculate numbers of pre-schools that fall inside each planning subzone.\n\n\nmpsz3414$`PreSch Count` <- lengths(st_intersects(mpsz3414,preschool3414))\n\n\n\n\n\n\n\nst_intersects(): count points in polygon\nst_intersection(): find polygon areas overlap\n\n\n\nNow check summary stats of PreSch Count column in each subzone.\n\nsummary(mpsz3414$`PreSch Count`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    0.00    3.00    5.96    9.00   58.00 \n\n\nTo list the planning subzone with the most number of pre-school, the top_n() of dplyr package can be used.\n\nkable(top_n(mpsz3414, 3, `PreSch Count`) %>%\n        arrange(desc(`PreSch Count`)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOBJECTID\nSUBZONE_NO\nSUBZONE_N\nSUBZONE_C\nCA_IND\nPLN_AREA_N\nPLN_AREA_C\nREGION_N\nREGION_C\nINC_CRC\nFMEL_UPD_D\nX_ADDR\nY_ADDR\nSHAPE_Leng\nSHAPE_Area\nPreSch Count\ngeometry\n\n\n\n\n189\n2\nTAMPINES EAST\nTMSZ02\nN\nTAMPINES\nTM\nEAST REGION\nER\n21658EAAF84F4D8D\n2014-12-05\n41122.55\n37392.39\n10180.624\n4339824\n58\nMULTIPOLYGON (((42196.76 38…\n\n\n290\n3\nWOODLANDS EAST\nWDSZ03\nN\nWOODLANDS\nWD\nNORTH REGION\nNR\nC90769E43EE6B0F2\n2014-12-05\n24506.64\n46991.63\n6603.608\n2553464\n47\nMULTIPOLYGON (((24786.75 46…\n\n\n199\n4\nBEDOK NORTH\nBDSZ04\nN\nBEDOK\nBD\nEAST REGION\nER\nA2254301F85C1EDF\n2014-12-05\n39429.21\n34737.62\n8414.962\n3203663\n31\nMULTIPOLYGON (((40284.24 35…\n\n\n\n\n\nTo calculate the density (# schools/subzone area) of preschool by planning subzone :\n\nmpsz3414 <- mpsz3414 %>%\n  mutate(AREA = st_area(mpsz3414),\n         DENSITY = `PreSch Count` /AREA * 1000000) %>% \n  arrange(desc(DENSITY))\n\nkable(head(mpsz3414))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOBJECTID\nSUBZONE_NO\nSUBZONE_N\nSUBZONE_C\nCA_IND\nPLN_AREA_N\nPLN_AREA_C\nREGION_N\nREGION_C\nINC_CRC\nFMEL_UPD_D\nX_ADDR\nY_ADDR\nSHAPE_Leng\nSHAPE_Area\nPreSch Count\nAREA\nDENSITY\ngeometry\n\n\n\n\n27\n8\nCECIL\nDTSZ08\nY\nDOWNTOWN CORE\nDT\nCENTRAL REGION\nCR\n65AA82AF6F4D925D\n2014-12-05\n29730.20\n29011.33\n2116.0947\n196619.86\n7\n196619.86 [m^2]\n35.60169 [1/m^2]\nMULTIPOLYGON (((29808.18 28…\n\n\n278\n3\nMANDAI ESTATE\nMDSZ03\nN\nMANDAI\nMD\nNORTH REGION\nNR\nF6266F7368DBB9AB\n2014-12-05\n27082.70\n45367.46\n1633.7084\n143137.94\n5\n143137.94 [m^2]\n34.93134 [1/m^2]\nMULTIPOLYGON (((27119.56 45…\n\n\n37\n4\nPHILLIP\nDTSZ04\nY\nDOWNTOWN CORE\nDT\nCENTRAL REGION\nCR\n615D4EDDEF809F8E\n2014-12-05\n29706.72\n29744.91\n871.5549\n39437.94\n1\n39437.94 [m^2]\n25.35630 [1/m^2]\nMULTIPOLYGON (((29814.11 29…\n\n\n291\n3\nSEMBAWANG CENTRAL\nSBSZ03\nN\nSEMBAWANG\nSB\nNORTH REGION\nNR\n772A64AB9A93FC3A\n2014-12-05\n26268.73\n47558.08\n3955.1176\n962437.40\n23\n962437.40 [m^2]\n23.89766 [1/m^2]\nMULTIPOLYGON (((26311.14 46…\n\n\n253\n3\nSERANGOON NORTH\nSGSZ03\nN\nSERANGOON\nSG\nNORTH-EAST REGION\nNER\nC685042EC58E5C55\n2014-12-05\n32458.80\n39597.64\n3610.7324\n684704.30\n15\n684704.30 [m^2]\n21.90727 [1/m^2]\nMULTIPOLYGON (((32860.5 397…\n\n\n272\n3\nSENGKANG TOWN CENTRE\nSESZ03\nN\nSENGKANG\nSE\nNORTH-EAST REGION\nNER\n5A2D0E9E6B285069\n2014-12-05\n35163.81\n41501.14\n5216.4005\n1455507.86\n30\n1455507.86 [m^2]\n20.61136 [1/m^2]\nMULTIPOLYGON (((35615.75 40…\n\n\n\n\n\nThe table above shows the top 6 highest density subzones ."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_1.html#explorotary-data-analysis-eda",
    "href": "Hands-on_Ex1/Hands-on_Ex1_1.html#explorotary-data-analysis-eda",
    "title": "Hands-on Exercise 1.1: Geospatial Data Wrangling with R",
    "section": "1.10 Explorotary Data Analysis (EDA)",
    "text": "1.10 Explorotary Data Analysis (EDA)\nIn practice, many geospatial analytics start with Exploratory Data Analysis. In this section, wewill learn how to use appropriate ggplot2 functions to create functional and yet truthful statistical graphs for EDA purposes.\nFirstly, we will plot a histogram to reveal the distribution of PreSch Density. Conventionally, hist() of R Graphics will be used as shown in the code chunk below.\n\nhist(mpsz3414$DENSITY)\n\n\n\n\nAlthough the syntax is very easy to use however the output is far from meeting publication quality. Furthermore, the function has limited room for further customisation.\nIn the code chunk below, appropriate ggplot2 functions will be used.\n\nStaticInteractive (plotly)\n\n\n\nq <- quantile(as.numeric(mpsz3414$DENSITY), probs = c(0.25, 0.5, 0.75))\n\nggplot(data=mpsz3414, \n       aes(x= as.numeric(DENSITY)))+\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  geom_vline(xintercept = q[2]+1, linetype='dashed', size = 0.5, color='blue') +\n  geom_vline(xintercept = q[3]+1, linetype='dashed', size = 0.5) +\n  annotate('text' , x= 4, y=75, label='50th \\npercentile', size = 2) +\n  annotate('text' , x= 9, y=75, label='75th \\npercentile', size = 2) +\n  labs(title = \"Are pre-school even distributed in Singapore?\",\n       subtitle= \"There are many planning sub-zones with a single pre-school, on the other hand, \\nthere are two planning sub-zones with at least 20 pre-schools\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Frequency\")\n\n\n\n\n\n\n\nlibrary(plotly)\nq <- quantile(as.numeric(mpsz3414$DENSITY), probs = c(0.25, 0.5, 0.75))\n\np <- ggplot(data=mpsz3414, \n       aes(x= as.numeric(DENSITY)))+\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  geom_vline(xintercept = q[2]+1, linetype='dashed', size = 0.5, color='blue') +\n  geom_vline(xintercept = q[3]+1, linetype='dashed', size = 0.5) +\n  annotate('text' , x= 4, y=75, label='50th \\npercentile', size = 2) +\n  annotate('text' , x= 9, y=75, label='75th \\npercentile', size = 2) +\n  labs(title = \"Are pre-school even distributed in Singapore?\",\n       subtitle= \"There are many planning sub-zones with a single pre-school, on the other hand, \\nthere are two planning sub-zones with at least 20 pre-schools\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Frequency\")\n\nggplotly(p)\n\n\n\n\n\n\n\n\nDIY: Using ggplot2 method, plot a scatterplot showing the relationship between Pre-school Density and Pre-school Count.\n\nggplot(data=mpsz3414, \n       aes(y = `PreSch Count`, \n           x= as.numeric(DENSITY)))+\n  geom_point(color=\"black\", \n             fill=\"light blue\") +\n  xlim(0, 40) +\n  ylim(0, 40) +\n  labs(title = \"\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Pre-school count\")"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_1.html#theories",
    "href": "Hands-on_Ex1/Hands-on_Ex1_1.html#theories",
    "title": "Hands-on Exercise 1.1: Geospatial Data Wrangling with R",
    "section": "Theories",
    "text": "Theories\n\nKML and shapefiles\nA KMZ file is a zipped (or compressed) KML file, and a SHZ is a zipped/compressed Shapefile.\nA shapefile is an Esri vector data storage format for storing the location, shape, and attributes of geographic features. It is stored as a set of related files and contains one feature class.\nThe shapefile format can spatially describe vector features: points, lines, and polygons, representing, for example, water wells, rivers, and lakes. Each item usually has attributes that describe it, such as name or temperature.\nKML and Shapefiles could contain the exact same data, however KML (Keyhole Markup Language) is much more suited to displaying time based track information, whereas shapefiles are more suited to displaying Geometries, like boundaries, areas, roads, etc.\nShapefiles are composed of 3 mandatory files\n·       . shp (geometry), <- multipolygon, polylines or points. Can only be one type in each file , can combined in layers\n·       . dbf (attributes) <- table\n·       . shx (index)  <- binds first two together\n\n\nGCS [Geographic Coordinate System] (3D) and PCS [Projected Coordinate System ] (2D)\nGCS: uses lat, long, elevation to locate positions on Earth. Units are in degree and metres. Earth is represented as a sphere. Eg. WGS84 (world Gedetic system 1984)\nPCS: Units are usually metres to locate position on a Flat surface. Involves projecting 3D Earth into a 2D plane. It distorts the true shapes, areas, distances, or directions to some extent, depending on the projection method chosen.\nPreserve:\n·       Conformal projections minimize distortion in shape\n·       Equidistant projections minimize distortion in distance\n·       Equal-area projection minimize distortion in area\n·       Azimuthal or True-direction projections minimize distortion in direction.\nGoogle maps uses Mercator projection system. It is chosen as it preserves direction and angles. It is useful for navigation (google map) . It is originally created for sea navigation in older days. The cons are that this projection does not preserve area and shape.\nSingapore uses SVY21 or the EPSG:3414 projected coordinate system.\n\n\nGeospatial data handling functions\n\nst_read & read sf: read simple features from file or database, or retrieve layer names and their geometry type(s)\nst write &write_sf: write simple features object to file or database\nst_as_sf: convert a sf object from a non-geospatial tabular data frame\nst as_text: convert to Well Known Text(WKT)\nst as_binary: convert to Well Known Binary(WKB)\nst_as_sfc: convert geometries to sfc (e.g., from WKT, WKB) as(x, “Spatial”): convert to Spatial*\nst transform(x, crs, …): convert coordinates of x to a different coordinate reference system\n\nThe code chunk below allows us to unsf the mpsz and work tbl_df or data.frame.\n\nmpsz_tbl_df <- as_tibble(mpsz)"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_2.html",
    "href": "Hands-on_Ex1/Hands-on_Ex1_2.html",
    "title": "Hands-on Exercise 1.2: Choropleth Mapping with R",
    "section": "",
    "text": "Choropleth mapping involves the symbolisation of enumeration units, such as countries, provinces, states, counties or census units, using area patterns or graduated colors. For example, a social scientist may need to use a choropleth map to portray the spatial distribution of aged population of Singapore by Master Plan 2014 Subzone Boundary."
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_2.html#getting-started",
    "href": "Hands-on_Ex1/Hands-on_Ex1_2.html#getting-started",
    "title": "Hands-on Exercise 1.2: Choropleth Mapping with R",
    "section": "2.2 Getting Started",
    "text": "2.2 Getting Started\nIn this hands-on exercise, we learn how to plot functional and truthful choropleth maps by using r packages called tmap package.\nBeside tmap package, four other R packages will be used. They are:\n\nreadr for importing delimited text file,\ntidyr for tidying data,\ndplyr for wrangling data and\nsf for handling geospatial data.\n\nAmong the four packages, readr, tidyr and dplyr are part of tidyverse package.\nLets us first load all the required libraries.\n\npacman::p_load(sf, tmap, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_2.html#importing-data-into-r",
    "href": "Hands-on_Ex1/Hands-on_Ex1_2.html#importing-data-into-r",
    "title": "Hands-on Exercise 1.2: Choropleth Mapping with R",
    "section": "2.3 Importing Data into R",
    "text": "2.3 Importing Data into R\n\n2.3.1 The Data\nThe Two datasets will be used to create the choropleth map are:\n\nMaster Plan 2014 Subzone Boundary (Web) (i.e. MP14_SUBZONE_WEB_PL) in ESRI shapefile format.\nSingapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2011-2020 in csv format (i.e. respopagesextod2011to2020.csv). This is an aspatial data fie. It can be downloaded at Department of Statistics, Singapore, the specific link can be found here. Although it does not contain any coordinates values, but it’s PA and SZ fields can be used as unique identifiers to geocode to MP14_SUBZONE_WEB_PL shapefile.\n\n\n\n2.3.2 Importing Geospatial Data into R\n\nmpsz <- st_read(dsn='data/geospatial',\n                layer = 'MP14_SUBZONE_WEB_PL')\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\yixin-neo\\ISSS624_AGA\\Hands-on_Ex1\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nCheck the projection system of mpsz. It is not in svy21 or epsg3414. We will need to convert it later.\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\nTake a look at first few records of data\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\nLets convert to EPSG3414 now.\n\nmpsz3414 <- st_transform(mpsz, 3414)\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\n\nhead(mpsz3414,3)\n\nSimple feature collection with 3 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 28160.23 ymin: 28369.47 xmax: 32362.39 ymax: 30247.18\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO    SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N PLN_AREA_C\n1        1          1 MARINA SOUTH    MSSZ01      Y    MARINA SOUTH         MS\n2        2          1 PEARL'S HILL    OTSZ01      Y          OUTRAM         OT\n3        3          3    BOAT QUAY    SRSZ03      Y SINGAPORE RIVER         SR\n        REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR\n1 CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84 29220.19\n2 CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06 29782.05\n3 CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96 29974.66\n  SHAPE_Leng SHAPE_Area                       geometry\n1   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n\n\n\n\n2.3.3 Importing Attribute Data into R\nNext, we will import respopagsex2000to2020.csv file into RStudio and save the file into an R dataframe called popagsex.\nThe task will be performed by using read_csv() function of readr package as shown in the code chunk below.\n\npopdata <- read_csv(\"data/aspatial/respopagesextod2011to2020.csv\")\nhead(popdata)\n\n# A tibble: 6 × 7\n  PA         SZ                     AG     Sex   TOD                   Pop  Time\n  <chr>      <chr>                  <chr>  <chr> <chr>               <dbl> <dbl>\n1 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 1- and 2-Room …     0  2011\n2 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 3-Room Flats       10  2011\n3 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 4-Room Flats       30  2011\n4 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 5-Room and Exe…    50  2011\n5 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HUDC Flats (exclud…     0  2011\n6 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males Landed Properties       0  2011\n\n\nSummary stats using skimr package.\n\nlibrary(skimr)\nskim(popdata)\n\n\nData summary\n\n\nName\npopdata\n\n\nNumber of rows\n984656\n\n\nNumber of columns\n7\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n5\n\n\nnumeric\n2\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nPA\n0\n1\n4\n23\n0\n55\n0\n\n\nSZ\n0\n1\n4\n29\n0\n335\n0\n\n\nAG\n0\n1\n6\n11\n0\n19\n0\n\n\nSex\n0\n1\n5\n7\n0\n2\n0\n\n\nTOD\n0\n1\n6\n39\n0\n8\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nPop\n0\n1\n39.86\n132.25\n0\n0\n0\n10\n2860\n▇▁▁▁▁\n\n\nTime\n0\n1\n2015.51\n2.88\n2011\n2013\n2016\n2018\n2020\n▇▇▇▇▇"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_2.html#data-preparation",
    "href": "Hands-on_Ex1/Hands-on_Ex1_2.html#data-preparation",
    "title": "Hands-on Exercise 1.2: Choropleth Mapping with R",
    "section": "2.3.4 Data preparation",
    "text": "2.3.4 Data preparation\nPrepare a data table with year 2020 values. The data table should include the variables PA, SZ, YOUNG, ECONOMY ACTIVE, AGED, TOTAL, DEPENDENCY.\n\nYOUNG: age group 0 to 4 until age group 20 to 24,\nECONOMY ACTIVE: age group 25-29 until age group 60-64,\nAGED: age group 65 and above,\nTOTAL: all age group, and\nDEPENDENCY: the ratio between young and aged against economy active group\n\n\n2.3.4.1 Data Wrangling\n\npivot_wider() (rows to column headers) of tidyr package, and\nmutate() (create new cal col), filter() (subset rows), group_by() and select() (select cols) of dplyr package\n\nThe complete code chunk:\n\npopdata2020 <- popdata %>% \n  filter(Time==2020) %>% \n  group_by(PA,SZ,AG) %>%   #<< for calculating POP column below\n  summarise(`POP` = sum(Pop)) %>% \n  ungroup() %>%\n  pivot_wider(names_from = AG,\n              values_from = POP) %>% \n  mutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[14])) %>% \n  mutate(`ECONOMY ACTIVE` = rowSums(.[7:13])+rowSums(.[15])) %>%\n  mutate(AGED = rowSums(.[16:21])) %>%\n  mutate(TOTAL = rowSums(.[3:21])) %>% \n  mutate(DEPENDENCY = (YOUNG+AGED)/`ECONOMY ACTIVE`) %>% \n  select(PA, SZ,YOUNG,'ECONOMY ACTIVE', AGED, TOTAL, DEPENDENCY)\n\nhead(popdata2020)\n\n# A tibble: 6 × 7\n  PA         SZ                    YOUNG `ECONOMY ACTIVE`  AGED TOTAL DEPENDENCY\n  <chr>      <chr>                 <dbl>            <dbl> <dbl> <dbl>      <dbl>\n1 Ang Mo Kio Ang Mo Kio Town Cent…  1290             2760   760  4810      0.743\n2 Ang Mo Kio Cheng San              5640            16460  6050 28150      0.710\n3 Ang Mo Kio Chong Boon             5100            15000  6470 26570      0.771\n4 Ang Mo Kio Kebun Bahru            4620            13010  5120 22750      0.749\n5 Ang Mo Kio Sembawang Hills        1880             3630  1310  6820      0.879\n6 Ang Mo Kio Shangri-La             3330             9050  3610 15990      0.767\n\n\nTo understand the first 6 lines of code in the code chunk above, print the output:\n\n\n# A tibble: 6 × 21\n  PA       SZ    `0_to_4` `10_to_14` `15_to_19` `20_to_24` `25_to_29` `30_to_34`\n  <chr>    <chr>    <dbl>      <dbl>      <dbl>      <dbl>      <dbl>      <dbl>\n1 Ang Mo … Ang …      170        280        340        270        260        310\n2 Ang Mo … Chen…     1060       1040       1160       1330       1720       2020\n3 Ang Mo … Chon…      850       1020       1070       1310       1610       1890\n4 Ang Mo … Kebu…      680        960       1010       1170       1410       1420\n5 Ang Mo … Semb…      210        400        450        500        500        340\n6 Ang Mo … Shan…      560        640        700        860        970       1030\n# ℹ 13 more variables: `35_to_39` <dbl>, `40_to_44` <dbl>, `45_to_49` <dbl>,\n#   `50_to_54` <dbl>, `55_to_59` <dbl>, `5_to_9` <dbl>, `60_to_64` <dbl>,\n#   `65_to_69` <dbl>, `70_to_74` <dbl>, `75_to_79` <dbl>, `80_to_84` <dbl>,\n#   `85_to_89` <dbl>, `90_and_over` <dbl>\n\n\n\n2.3.4.2 Joining the attribute data and geospatial data\nBefore we can perform the georelational join, one extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ fields are made up of upper- and lowercase. On the other, hand the SUBZONE_N and PLN_AREA_N are in uppercase.\nSince mpsz’s SUBZONE_N and PLN_AREA_N are in uppercase, we have to convert PA and SZ fields in popdata2020 into all uppercase using:\n\nmutate.at()<- mutate multiple columns\nfirst argument of mutate_at(): .var <- list of columns generated by vars()\nsecond argument: .funs <- a function fun, a quosure style lambda. The function used in toupper() <- to upper case\n\nThere are many ways to achieve the final output\n\nProf’s bookAlternative\n\n\n\npopdata2020 <- popdata2020 %>% \n  mutate_at(.vars= vars(PA, SZ),\n            .funs = funs(toupper)) %>% \n  filter(`ECONOMY ACTIVE` >0)\n\npopdata2020\n\n# A tibble: 234 × 7\n   PA         SZ                   YOUNG `ECONOMY ACTIVE`  AGED TOTAL DEPENDENCY\n   <chr>      <chr>                <dbl>            <dbl> <dbl> <dbl>      <dbl>\n 1 ANG MO KIO ANG MO KIO TOWN CEN…  1290             2760   760  4810      0.743\n 2 ANG MO KIO CHENG SAN             5640            16460  6050 28150      0.710\n 3 ANG MO KIO CHONG BOON            5100            15000  6470 26570      0.771\n 4 ANG MO KIO KEBUN BAHRU           4620            13010  5120 22750      0.749\n 5 ANG MO KIO SEMBAWANG HILLS       1880             3630  1310  6820      0.879\n 6 ANG MO KIO SHANGRI-LA            3330             9050  3610 15990      0.767\n 7 ANG MO KIO TAGORE                1940             4480  1530  7950      0.775\n 8 ANG MO KIO TOWNSVILLE            4190            11950  5100 21240      0.777\n 9 ANG MO KIO YIO CHU KANG EAST     1110             2410   750  4270      0.772\n10 ANG MO KIO YIO CHU KANG WEST     5690            13750  4680 24120      0.754\n# ℹ 224 more rows\n\n\nThe reason for filtering is because some subzones are not inhibited by residents as seen below.\n\n\n\npopdata2020 %>%\n  mutate(PA = toupper(PA),\n         SZ = toupper(SZ)) %>% \n  filter(`ECONOMY ACTIVE` >0)\n\n\n\n\nNext, left_join() of dplyr is used to join the geographical data and attribute table using planning subzone name e.g. SUBZONE_N and SZ as the common identifier.\n\nmpsz_pop2020 <-left_join(mpsz3414, popdata2020,\n                         by = c('SUBZONE_N' = 'SZ'))\nmpsz_pop2020\n\nSimple feature collection with 323 features and 21 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area              PA YOUNG ECONOMY ACTIVE AGED\n1  29220.19   5267.381  1630379.3            <NA>    NA             NA   NA\n2  29782.05   3506.107   559816.2          OUTRAM   930           3130 2120\n3  29974.66   1740.926   160807.5 SINGAPORE RIVER     0             40   10\n4  29933.77   3313.625   595428.9     BUKIT MERAH  2600           7450 3320\n5  30005.70   2825.594   387429.4     BUKIT MERAH  2760           6160 1740\n6  29991.38   4428.913  1030378.8     BUKIT MERAH  2800           7340 3420\n7  30230.86   3275.312   551732.0     BUKIT MERAH  2750           8080 3610\n8  30222.86   2208.619   290184.7 SINGAPORE RIVER     0             50   10\n9  29893.78   6571.323  1084792.3      QUEENSTOWN  1120           2770  610\n10 30104.18   3454.239   631644.3      QUEENSTOWN    30            160   60\n   TOTAL DEPENDENCY                       geometry\n1     NA         NA MULTIPOLYGON (((31495.56 30...\n2   6180  0.9744409 MULTIPOLYGON (((29092.28 30...\n3     50  0.2500000 MULTIPOLYGON (((29932.33 29...\n4  13370  0.7946309 MULTIPOLYGON (((27131.28 30...\n5  10660  0.7305195 MULTIPOLYGON (((26451.03 30...\n6  13560  0.8474114 MULTIPOLYGON (((25899.7 297...\n7  14440  0.7871287 MULTIPOLYGON (((27746.95 30...\n8     60  0.2000000 MULTIPOLYGON (((29351.26 29...\n9   4500  0.6245487 MULTIPOLYGON (((20996.49 30...\n10   250  0.5625000 MULTIPOLYGON (((24472.11 29...\n\n\n\n\n\n\n\n\nImportant\n\n\n\nleft_join() of dplyr package is used with mpsz simple feature data frame as the left data table is to ensure that the output will be a simple features data frame.\n\n\nOriginal # rows in mpsz3414 = 323\nOriginal # of rows in popdata2022 = 234\nFinal # of rows in mpsz_pop2020 = 323\nWrite the data as rds, can preserve the format of data.\n\n# write_rds(mpsz_pop2020, 'data/rds/mpszpop2020.rds')\n# mpsz_pop2020 <- readRDS('data/rds/mpszpop2020.rds')\n\nLets take a look at the df mpsz_pop2020"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_2.html#choropleth-mapping-geospatial-data-using-tmap",
    "href": "Hands-on_Ex1/Hands-on_Ex1_2.html#choropleth-mapping-geospatial-data-using-tmap",
    "title": "Hands-on Exercise 1.2: Choropleth Mapping with R",
    "section": "2.4 Choropleth Mapping Geospatial Data Using tmap",
    "text": "2.4 Choropleth Mapping Geospatial Data Using tmap\nTwo approaches can be used to prepare thematic map using tmap, they are:\n\nPlotting a thematic map quickly by using qtm().\nPlotting highly customisable thematic map by using tmap elements.\n\n\n2.4.1 Plotting a choropleth map quickly by using qtm()\nThe easiest and quickest to draw a choropleth map using tmap is using qtm(). It is concise and provides a good default visualisation in many cases.\n\ntmap_mode('plot')\n#tmap_mode('view')\n#ttm()\n#last_map()\n#tmap_options(check.and.fix = TRUE)\n\nqtm(mpsz_pop2020,\n    fill='DEPENDENCY')\n\n\n\n\nThings to learn from the code chunk above:\n\ntmap_mode() with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.\nfill argument is used to map the attribute (i.e. DEPENDENCY)\n\n\n\n2.4.2 Creating a Choropleth map by using tmap’s elements\ntmap’ drawing elements (unlike qtm() ) is able to give us finer control over our chloropleth map.\ntm_shape() <- define input data and specify the shape object / spatial data object\ntm_fill() <- fills polygons (no border)\n\nstyle: method to process the color scale when col (data variable) is a numeric variable. To process numeric and categorical use “cat”\npalette : palettes names or vectors of colors. default is taken from tm_layout’s aes.paletttes argument. To reverse the colour scheme , add a “-” prefix.\n\ntm_borders() <- draws the borders of polygons (alpha is 0-1, transparency)\ntm_polygons() (= tm_fill() + tm_borders() )<- fills the polygon and draws the polygon borders\n*qtm = shape + polygon or * qtm = shape + fill + border\ntm_layout() <- specify map layout\n\naes.palette <- ‘seq’ (sequential palettes), ‘div’ (diverging palettes) , ‘cat’ (categorical palettes)\n\ntm_compass() <- create map compass\ntm_scale_bar() <- creates scale bar\ntm_grid() <- creates grid lines (alpha is 0-1, transparency of grid lines)\ntm_credits() <- create a text for credits\n\nHigh quality graphmpsz_pop2020 table\n\n\n\n\nShow the code\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Reds\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\n\n\nlibrary(knitr)\nkable(head(mpsz_pop2020,3))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOBJECTID\nSUBZONE_NO\nSUBZONE_N\nSUBZONE_C\nCA_IND\nPLN_AREA_N\nPLN_AREA_C\nREGION_N\nREGION_C\nINC_CRC\nFMEL_UPD_D\nX_ADDR\nY_ADDR\nSHAPE_Leng\nSHAPE_Area\nPA\nYOUNG\nECONOMY ACTIVE\nAGED\nTOTAL\nDEPENDENCY\ngeometry\n\n\n\n\n1\n1\nMARINA SOUTH\nMSSZ01\nY\nMARINA SOUTH\nMS\nCENTRAL REGION\nCR\n5ED7EB253F99252E\n2014-12-05\n31595.84\n29220.19\n5267.381\n1630379.3\nNA\nNA\nNA\nNA\nNA\nNA\nMULTIPOLYGON (((31495.56 30…\n\n\n2\n1\nPEARL’S HILL\nOTSZ01\nY\nOUTRAM\nOT\nCENTRAL REGION\nCR\n8C7149B9EB32EEFC\n2014-12-05\n28679.06\n29782.05\n3506.107\n559816.2\nOUTRAM\n930\n3130\n2120\n6180\n0.9744409\nMULTIPOLYGON (((29092.28 30…\n\n\n3\n3\nBOAT QUAY\nSRSZ03\nY\nSINGAPORE RIVER\nSR\nCENTRAL REGION\nCR\nC35FEFF02B13E0E5\n2014-12-05\n29654.96\n29974.66\n1740.926\n160807.5\nSINGAPORE RIVER\n0\n40\n10\n50\n0.2500000\nMULTIPOLYGON (((29932.33 29…\n\n\n\n\n\n\n\n\n\n2.4.2.1 Drawing a base map\nBasic building blocks are tm_fill() and tm_polygons().\ntm_polygons() = fill + borders\n\ntm_borders()tm_fill()\n\n\nBase Map\n\ntm_shape(mpsz_pop2020) +\n  tm_borders(lwd = 0.1,  alpha = 1)\n\n\n\n\n\n\nTo show the geographical distribution of a selected variable by planning subzone, we just need to assign the target variable such as Dependency to tm_polygons().\n\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY')\n\n\n\n\n\n\n\n\n\n2.4.2.2 Drawing a choropleth map using tm_polygons()\nTo draw a choropleth map showing the geographical distribution of a selected variable by planning subzone, we just need to assign the target variable such as Dependency to tm_polygons().\n\nNo variableWith variable\n\n\n\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\")\n\n\n\n\n\n\n\nThings to learn from tm_polygons():\n\nThe default interval binning used to draw the choropleth map is called “pretty”. A detailed discussion of the data classification methods supported by tmap will be provided in sub-section 4.3.\nThe default colour scheme used is YlOrRd of ColorBrewer. You will learn more about the color scheme in sub-section 4.4.\nBy default, Missing value will be shaded in grey.\n\n\n\n2.4.2.3 Drawing a choropleth map using tm_fill() + *tm_border()**\nActually, tm_polygons() is a wraper of tm_fill() and tm_border(). tm_fill() shades the polygons by using the default colour scheme and tm_borders() adds the borders of the shapefile onto the choropleth map.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\") +\n  tm_borders(lwd = 0.1,  alpha = 1)\n\n\n\n\nApart from alpha (transparency number 0 - 1), other arguments are\n\ncol = border colour,\nlwd = border line width. The default is 1, and\nlty = border line type. The default is “solid”.\n\n\n\n\n2.4.3 Data classification methods of tmap\nMost choropleth maps employ some methods of data classification. The point of classification is to take a large number of observations and group them into data ranges or classes.\ntmap provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks.\nTo define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.\n\n2.4.3.1 Plotting choropleth maps with built-in classification methods\nThe codes below uses quantile classification with 5 classes.\n\nfill + borderpolygons\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nUsing equal classification method\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nDistribution of quantile data classification method are more evenly distributed then equal data classification method.\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",n = 5,\n          style = \"jenks\" )\n\n\n\n\n\n\n\n\nWarning: Maps Lie!\n\n\nDIY: Using what you had learned, prepare choropleth maps by using different classification methods supported by tmap and compare their differences.\n\nUsing tmap_arrange:\n\nkmeans<- tm_shape(mpsz_pop2020)+\n    tm_fill(\"DEPENDENCY\", n = 5, style = 'kmeans') +\n  tm_borders(alpha = 0.5)\n\nsd <- tm_shape(mpsz_pop2020)+\n    tm_fill(\"DEPENDENCY\", n = 5, style = 'sd') +\n  tm_borders(alpha = 0.5)\n\nfisher <- tm_shape(mpsz_pop2020)+\n    tm_fill(\"DEPENDENCY\", n = 5, style = 'fisher') +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(kmeans, sd, fisher, asp = 4, nrow=3)\n\n\n\n\n\nDIY: Preparing choropleth maps by using similar classification method but with different numbers of classes (i.e. 2, 6, 10, 20). Compare the output maps, what observation can you draw?\n\nAssigning multiple values to at least one of the aesthetics arguments.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c('DEPENDENCY','DEPENDENCY'),\n          style= c('jenks','jenks'),\n          n = c(3,10),\n          palette= list('Greens', 'Greens')) +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.position = c('right','bottom'),\n            legend.width = 0.5,\n            legend.height = 0.4,\n            legend.text.size = 0.35 )\n\n\n\n\n\n\n2.4.3.2 Plotting choropleth maps with custome break\nThe breakpoints can be set explicitly by means of the breaks argument to the tm_fill().\n\nbreaks include min and max\nto have n categories, n+1 elements to be specified in breaks option\nvalues must be in increasing order\n\nGood practise: descriptive statistics on variable before setting break points\n\nsummary(mpsz_pop2020$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.6519  0.7025  0.7742  0.7645 19.0000      92 \n\n\nWith reference to summary stats and boxplot above,\n\nbreak points are 0.6, 0.7, 0.8, 0.9\nmin = 0 and max = 1.0\nbreak vector is thus c(0, 0.6, 0.7, 0.8, 0.9, 1.0)\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", breaks = c(0, 0.6, 0.7, 0.8, 0.9, 1.0)) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n2.4.4 Colour scheme\n\n2.4.4.1 Using ColourBrewer palette (predefined)\n(YIOrRd, YIORrBr, YIGnBu, YIGn, Reds, RdPu, Purples, PuRd, PuBuGn, PuBu, OrRd, Oranges, Greys, Greens, GnBu, BuPu, BuGn, Blues)\n\n\n\n\n\nAssign the preferred colour to palette argument of tm_fill()\n\nnormalreverse\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"Blues\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\nReverse the colour scheme by adding “-”\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n2.4.5 Map Layouts\n\ncustomise title, scale bar, compass, margins, aspect ratios\nother than colour palette and data classification (breaks) which is done in tm_fill()\n\n\n2.4.5.1 Map Legend\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n2.4.5.2 Map style\ntmap allows a wide variety of layout settings to be changed. They can be called by using tmap_style()\nPredefined styles: ‘white’, ‘gray’, ‘natural’, ‘bw’, ‘classic’, ‘cobalt’, albatross’, ‘beaver’, ‘col_blind’, ‘watercolor’\nBelow is an example of classic style\n\ngraynaturalbwclassiccobaltbeaver\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)+\n  tmap_style('gray')\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)+\n  tmap_style('natural')\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)+\n  tmap_style('bw')\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)+\n  tmap_style('classic')\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"-RdPu\") +\n  tm_borders(alpha = 0.5)+\n  tmap_style('cobalt')\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"-Purples\") +\n  tm_borders(alpha = 0.5)+\n  tmap_style('beaver')\n\n\n\n\n\n\n\n\n\n2.4.5.3 Cartographic Furniture\nCan include other map furniture like compass, scale bar, and grid lines\ntmap_style has to be used at the last, think cannot mix with tm\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Reds\",\n          title = \"No. of persons\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio \\nby planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.0,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\")) +\n  tmap_style('natural')\n\n\n\n\nTo reset the default style, refer below\n\ntmap_style(\"white\")\n\n\n\n\n2.4.6 Drawing Small Multiple Choropleth Maps\nSmall multiple maps, also referred to as facet maps, are composed of many maps arrange side-by-side, and sometimes stacked vertically. Small multiple maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.\nIn tmap, small multiple maps can be plotted in three ways:\n\nby assigning multiple values to at least one of the asthetic arguments,\nby defining a group-by variable in tm_facets(), and\nby creating multiple stand-alone maps with tmap_arrange().\n\n\n2.4.6.1 By assigning multiple values to at least one of the aesthetic arguments\nSmall multiple choropleth maps are created by\n\n2.4.6.1.1 Defining ncols in tm_fill() : c(‘YOUNG’, ‘AGED’)\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\"),\n            legend.height = 0.35, \n            legend.width = 0.35) +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n\n\n\n\n\n\n2.4.6.1.2 Assigning multiple values to at least one of the aesthetic arguments\n\nshape + polygon method (Prof’s)\n\n\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"),\n            legend.height = 0.35, \n            legend.width = 0.35) +\n  tmap_style('white')\n\n\n\n\n\n\n\n\nshape + fill + borders method (NYX’s)\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c('YOUNG', 'AGED','TOTAL'),\n          style=c('equal', 'quantile', 'equal'),\n          palette= list('Blues', 'Greens', 'Reds')) +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.position = c('right','bottom'),\n            legend.height = 0.35, \n            legend.width = 0.35)\n\n\n\n\n\n\n\n2.4.6.2 By defining a group-by variable in tm_facets()\nIn this example, multiple small choropleth maps are created by using tm_facets().\nthres.poly: number that specifies the threshold at which polygons are taken into account. The number itself corresponds to the proportion of the area sizes of the polygons to the total polygon size. By default, all polygons are drawn.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by=\"REGION_N\", \n            free.coords=TRUE, \n            drop.shapes=TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n2.4.6.3 By creating multiple stand-alone maps with tmap_arrange()\nCreating multiple stand-alone maps with tmap_arrange() asp : aspect ratio\nnrow : number of rows (ncols)\n\nyoungmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              style = \"quantile\", \n              palette = \"Blues\") +\n  tm_layout(legend.position = c('right','bottom'),\n          legend.height = 0.5, \n          legend.width = 0.35)\n\nagedmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\", \n              style = \"quantile\", \n              palette = \"Blues\") +\n  tm_layout(legend.position = c('right','bottom'),\n        legend.height = 0.5, \n        legend.width = 0.35)\n\ntmap_arrange(youngmap, agedmap, asp=3, ncol=1, nrow=2)\n\n\n\n\n\n\n\n2.4.7 Mappping Spatial Object Meeting a Selection Criterion\nUse selection funtion to map spatial objects meeting the selection criterion. The comma , is used to indicate that we want to select all columns for the rows that meet the condition.\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ])+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.3) +\n  tm_layout(main.title = \"Mapping spatial obj with conditions \\n(Central Region)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.outside = TRUE,\n            legend.height = 0.3, \n            legend.width = 0.3,\n            legend.title.size= 0.8,\n            legend.text.size= 0.6,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE,\n            bg.color = \"mintcream\") + #call colors()\n  tm_borders(alpha = 0.5)\n\n\n\n\n\nWhat to do if legend overlaps with map?\n\n\nreduce legend.text.size or legend.height and legend.width\nadjust inner.margin\n\n\nAdjust background colours with its corresponding text colours.\n\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ])+\n  tm_polygons(\"DEPENDENCY\") +\n    tm_layout(main.title = \"Mapping spatial obj with conditions \\n(Central Region)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            #legend.outside = TRUE,\n            legend.height = 0.3, \n            legend.width = 0.3,\n            legend.title.size= 0.8,\n            legend.text.size= 0.6,\n            inner.margins = c(0.01, 0.01, 0, .15), # ensures legend does not overlap with chart c(bottom,top,left,right)\n            frame = FALSE,\n            legend.position = c(\"right\", \"top\"),\n            bg.color = \"black\",\n            main.title.color = 'white',\n            legend.title.color = 'white',\n            legend.text.color= 'white')\n\n\n\n\n\n\n\n\n\n2.4.8. Tmap summary\nFrom chap 2, using tmap package to plot\n1. tm_shape+ tm_polygon\n2. tm_shape+ tm_fill + tm_borders _ tm_layout\n3. qtm\nChap 2: To plot small multiple chloroplath maps via qtm or tmap elements:\n1. Add multiple values to tm_polygon or tm_fill\n2. Tm_facets\n3. Tm_arrange\nChap 3: To plot small multiple layered chloroplath maps via plot() method:\n 4. To arrange the maps via plot(),\npar(mfrow=c(2,2)) <- 2x2 layout\nFrom chap 3: to add layers to a plot\n1. just keep repeating plot(weight matrix ,coords,add=TRUE)\nhttps://rstudio-pubs-static.s3.amazonaws.com/730482_d7889d9c65c8422f843b3d4e0196633c.html"
  },
  {
    "objectID": "Hands-on_Ex1/Hands-on_Ex1_2.html#reference",
    "href": "Hands-on_Ex1/Hands-on_Ex1_2.html#reference",
    "title": "Hands-on Exercise 1.2: Choropleth Mapping with R",
    "section": "2.5 Reference",
    "text": "2.5 Reference\n\n2.5.1 All about tmap package\n\ntmp arguments and defaults : Introduction to Geospatial Visualization with the tmap package\ntmap: Thematic Maps in R\ntmap\ntmap: get started!\ntmap: changes in version 2.0\ntmap: creating thematic maps in a flexible way (useR!2015)\nExploring and presenting maps with tmap (useR!2017)\n\n\n\n2.5.2 Geospatial data wrangling\n\nsf: Simple Features for R\nSimple Features for R: StandardizedSupport for Spatial Vector Data\nReading, Writing and Converting Simple Features\n\n\n\n2.5.3 Data wrangling\n\ndplyr\nTidy data\ntidyr: Easily Tidy Data with ‘spread()’ and ‘gather()’ Functions\n\n\n# there are 111 arguments, run the code below to see the defaults\ntmap_options()"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_1.html",
    "href": "Hands-on_Ex2/Hands-on_Ex2_1.html",
    "title": "Hands-on Exercise 2.1: Spatial Weights and Applications",
    "section": "",
    "text": "In this hands-on exercise, we will learn how to compute spatial weights using R. By the end to this hands-on exercise, we will be able to:\n\nimport geospatial data using appropriate function(s) of sf package,\nimport csv file using appropriate function of readr package,\nperform relational join using appropriate join function of dplyr package,\ncompute spatial weights using appropriate functions of spdep package, and\ncalculate spatially lagged variables using appropriate functions of spdep package."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_1.html#the-study-area-and-data",
    "href": "Hands-on_Ex2/Hands-on_Ex2_1.html#the-study-area-and-data",
    "title": "Hands-on Exercise 2.1: Spatial Weights and Applications",
    "section": "8.2 The Study Area and Data",
    "text": "8.2 The Study Area and Data\nTwo data sets will be used in this hands-on exercise, they are:\n\nHunan county boundary layer. This is a geospatial data set in ESRI shapefile format.\nHunan_2012.csv: This csv file (aspatial) contains selected Hunan’s local development indicators in 2012.\n\n\n8.2.1 Getting Started\n\npacman::p_load(sf, spdep, tmap, tidyverse, knitr)"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_1.html#getting-the-data-into-r-environment",
    "href": "Hands-on_Ex2/Hands-on_Ex2_1.html#getting-the-data-into-r-environment",
    "title": "Hands-on Exercise 2.1: Spatial Weights and Applications",
    "section": "8.3 Getting the Data Into R Environment",
    "text": "8.3 Getting the Data Into R Environment\n8.3.1 Import shapefile into r environment\nThe code chunk below uses st_read() of sf package to import Hunan shapefile into R. The imported shapefile will be simple features Object of sf.\n\nhunan <- st_read(dsn='data/geospatial',\n                 layer = 'Hunan')\n\nReading layer `Hunan' from data source \n  `C:\\yixin-neo\\ISSS624_AGA\\Hands-on_Ex2\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\nclass(hunan)\n\n[1] \"sf\"         \"data.frame\"\n\n\nhunan is in WSG84 coordinate system.\n\nhead(hunan,3) %>% kable()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNAME_2\nID_3\nNAME_3\nENGTYPE_3\nShape_Leng\nShape_Area\nCounty\ngeometry\n\n\n\n\nChangde\n21098\nAnxiang\nCounty\n1.869074\n0.1005619\nAnxiang\nPOLYGON ((112.0625 29.75523…\n\n\nChangde\n21100\nHanshou\nCounty\n2.360691\n0.1997875\nHanshou\nPOLYGON ((112.2288 29.11684…\n\n\nChangde\n21101\nJinshi\nCounty City\n1.425620\n0.0530241\nJinshi\nPOLYGON ((111.8927 29.6013,…\n\n\n\n\n\n\n8.3.2 Import csv file into r environment\nNext, we will import Hunan_2012.csv into R by using read_csv() of readr package. The output is R dataframe class.\n\nhunan2012 <- read_csv('data/aspatial/Hunan_2012.csv')\nhead(hunan2012,3) %>% kable()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCounty\nCity\navg_wage\ndeposite\nFAI\nGov_Rev\nGov_Exp\nGDP\nGDPPC\nGIO\nLoan\nNIPCR\nBed\nEmp\nEmpR\nEmpRT\nPri_Stu\nSec_Stu\nHousehold\nHousehold_R\nNOIP\nPop_R\nRSCG\nPop_T\nAgri\nService\nDisp_Inc\nRORP\nROREmp\n\n\n\n\nAnhua\nYiyang\n30544\n10967.0\n6831.7\n456.72\n2703.0\n13225.0\n14567\n9276.9\n3954.9\n3528.3\n2718\n494.31\n441.4\n338.0\n54.175\n32.830\n290.4\n234.5\n101\n670.3\n5760.6\n910.8\n4942.253\n5414.5\n12373\n0.7359464\n0.8929619\n\n\nAnren\nChenzhou\n28058\n4598.9\n6386.1\n220.57\n1454.7\n4941.2\n12761\n4189.2\n2555.3\n3271.8\n970\n290.82\n255.4\n99.4\n33.171\n17.505\n104.6\n121.9\n34\n243.2\n2386.4\n388.7\n2357.764\n3814.1\n16072\n0.6256753\n0.8782065\n\n\nAnxiang\nChangde\n31935\n5517.2\n3541.0\n243.64\n1779.5\n12482.0\n23667\n5108.9\n2806.9\n7693.7\n1931\n336.39\n270.5\n205.9\n19.584\n17.819\n148.1\n135.4\n53\n346.0\n3957.9\n528.3\n4524.410\n14100.0\n16610\n0.6549309\n0.8041262\n\n\n\n\n\n\n\n8.3.3 Performing relational join\nThe code chunk below will be used to update the attribute table of hunan’s SpatialPolygonsDataFrame with the attribute fields of hunan2012 dataframe. This is performed by using left_join() of dplyr package.\nAs the join columns are not specified, this function will assume that columns with the same names, e.g., ‘county’ in both dfs will be the join columns.\nThe select() will retain the columns indicated in the resulting joined df.\n\nhunan <- left_join(hunan, hunan2012) %>% \n  select(1:4,7,15)\nclass(hunan)\n\n[1] \"sf\"         \"data.frame\"\n\n\nNote the geospatial characteristics of hunan is retained.\n\nhead(hunan,3) %>% kable\n\n\n\n\n\n\n\n\n\n\n\n\n\nNAME_2\nID_3\nNAME_3\nENGTYPE_3\nCounty\nGDPPC\ngeometry\n\n\n\n\nChangde\n21098\nAnxiang\nCounty\nAnxiang\n23667\nPOLYGON ((112.0625 29.75523…\n\n\nChangde\n21100\nHanshou\nCounty\nHanshou\n20981\nPOLYGON ((112.2288 29.11684…\n\n\nChangde\n21101\nJinshi\nCounty City\nJinshi\n34592\nPOLYGON ((111.8927 29.6013,…"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_1.html#visualising-regional-development-indicator",
    "href": "Hands-on_Ex2/Hands-on_Ex2_1.html#visualising-regional-development-indicator",
    "title": "Hands-on Exercise 2.1: Spatial Weights and Applications",
    "section": "8.4 Visualising Regional Development Indicator",
    "text": "8.4 Visualising Regional Development Indicator\nNow, we are going to prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using qtm() of tmap package.\n\nbasemap <- tm_shape(hunan)+\n  tm_polygons() +\n  tm_text('NAME_3',\n          size = 0.5)\n\ngdppc <- tm_shape(hunan)+\n  tm_polygons('GDPPC') +\n    tm_layout(legend.height = 0.20, \n            legend.width = 0.25)\n  \n# or gdppc <- qtm(hunan, \"GDPPC\")\n\ntmap_arrange(basemap, gdppc,\n           asp=1,\n           ncol=2)"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_1.html#computing-contiguity-spatial-weights",
    "href": "Hands-on_Ex2/Hands-on_Ex2_1.html#computing-contiguity-spatial-weights",
    "title": "Hands-on Exercise 2.1: Spatial Weights and Applications",
    "section": "8.5 Computing Contiguity Spatial Weights",
    "text": "8.5 Computing Contiguity Spatial Weights\nIn this section, we will use poly2nb() of spdep package to compute contiguity weight matrices for the study area. This function builds a neighbours list based on regions with contiguous boundaries. Use this if we know that for a variable, sharing common boundary increases spatial interaction.\nBy default, ‘queen’ argument is set to TRUE: two polygons sharing one shared boundary point will meet contiguity condition. Returns a list of first order neighbours using the Queen criteria.\nIf ‘queen’ argument is set to FALSE: requires more than one shared boundary point. (but may not mean a shared boundary line)\n\n8.5.1 Computing (QUEEN) contiguity based neighbours\nThe code chunk below is used to compute Queen contiguity weight matrix.\n\nwm_q <- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\nThe summary report above shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours. There are two area units with only one heighbours.\nwm_q (weights matrix queen) class: ‘nb’\n\nclass(wm_q)\n\n[1] \"nb\"\n\n\nA quick peak at wm_q\n\nhead(wm_q,3)\n\n[[1]]\n[1]  2  3  4 57 85\n\n[[2]]\n[1]  1 57 58 78 85\n\n[[3]]\n[1]  1  4  5 85\n\n\nFor each polygon in our polygon object, wm_q lists all neighboring polygons. For example, to see the neighbors for the first polygon in the object, type:\n\nwm_q[[1]]\n\n[1]  2  3  4 57 85\n\n\nPolygon 1 has 5 neighbors. The numbers represent the polygon IDs as stored in hunan SpatialPolygonsDataFrame class.\nWe can retrive the county name of Polygon ID=1 by using the code chunk below:\n\nhunan$County[1]\n\n[1] \"Anxiang\"\n\n\nPolygon ID=1 is Anxiang county.\nTo reveal the county names of the five neighboring polygons, the code chunk will be used:\n\nx1 <- wm_q[[1]]\nhunan$County[c(x1)]\n\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n\n\nThe printed output above shows that the GDPPC of the five nearest neighbours based on Queen’s method are 20981, 34592, 24473, 21311 and 22879 respectively.\nTo display the complete weight matrix, use str()\n\nstr(wm_q)\n\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"sym\")= logi TRUE\n\n#wm_q[1:10]\n#methods(class = class(wm_q))\n\n\n\n8.5.2 Creating (ROOK) contiguity based neighbours\nThe code chunk below is used to compute Rook contiguity weight matrix.\n\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n\n\nThe summary report above shows that there are 88 area units in Hunan. The most connect area unit has 10 neighbours. There are two area units with only one heighbours.\n\n\n8.5.3 Visualising contiguity weights (find centroid coords first)\nA connectivity graph takes a point and displays a line to each neighbouring point.\n\nneed a point in polygon via polygon centroids (its lat & long) <- calculate using the sf package first\n\nTo obtain coordinates in a separate data frame\n\ninput vector is the geometry column of us.bound (in hunan), an sf object <- a polygon\nUsing hunan$geometry[[1]]: The input vector of the FIRST POLYGON looks like POLYGON ((112.0625 29.75523, 112.069 29.74544, 112.0707 29.7415, 112.0716 29.73667, …. , 112.0625 29.75523).\nTo find the centroid (CG) of one polygon, use the st_centroid() function, which is a formula shorthand for a small anonymous function (lambda function). It takes an argument represented by .x. st_centroid(.x)[[1]] extracts the X-coordinate (longitude) of the centroid while st_centroid(.x)[[2]] extracts the Y-coords.\n\nX and YX onlyY only\n\n\n\n#hunan$geometry[[1]]\nst_centroid(hunan$geometry[[1]])\n\n\n\n\nst_centroid(hunan$geometry[[1]])[[1]]\n\n[1] 112.1531\n\n\n\n\n\nst_centroid(hunan$geometry[[1]])[[2]]\n\n[1] 29.44362\n\n\n\n\n\n\nmap_dbl(...) is a function from the purrr package that applies a function to each element of a list or vector and returns the results as a double vector. In this case, the function being applied is the expression following ~. Example of how this function is used in a simple way:\n\n# Example list of vectors\nlist_of_vectors <- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))\n\n# Applying a function to calculate the sum of each vector\nmap_dbl(list_of_vectors, ~ sum(.x))\n\n a  b  c \n 6 15 24 \n\n\nAfter finding centroid, to access longitude values\n\ndouble bracket notation [[ ]] and 1\n\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\nlongitude\n\n [1] 112.1531 112.0372 111.8917 111.7031 111.6138 111.0341 113.7065 112.3460\n [9] 112.8169 113.3534 113.8942 112.4006 112.5542 113.6636 112.9206 113.1883\n[17] 113.4521 112.4209 113.0152 112.6350 112.7087 112.9095 111.9522 110.2606\n[25] 110.0921 109.7985 109.5765 109.7211 109.7339 109.1537 110.6442 110.5916\n[33] 109.5984 111.4783 112.1745 111.2315 110.3149 111.3248 110.5859 110.9593\n[41] 111.8296 110.1926 110.7334 110.9123 111.4599 112.5268 112.3406 109.5602\n[49] 109.5071 109.9954 109.4273 109.7587 109.5044 109.9899 109.9664 111.3785\n[57] 112.4350 112.5558 111.7379 112.1831 111.9743 111.7009 112.2196 112.6472\n[65] 113.5102 113.1172 113.7089 112.7963 110.9276 113.6420 113.4577 113.8404\n[73] 113.4758 113.1428 110.3017 113.1957 111.7410 112.1831 111.3390 111.8208\n[81] 110.0753 112.3965 112.7683 113.1679 111.4495 112.7956 111.5896 111.2393\n\n\n\nTo access the latitude value\n\ndouble bracket notation [[ ]] and 2\n\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\n\nWith both longitude and latitude, use cbind() to combine both in the same object,\n\ncoords <- cbind(longitude, latitude)\nhead(coords)\n\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n\n\n\n8.5.3.1 Plotting Queen contiguity based neighbours map\nwm_ q is weight matrix using queen method (88 rows of list of neighbours)\ncoords is an array of x,y coordinates of centroids for each of the 88 counties\n\nplot(hunan$geometry, border=\"lightgrey\", main=\"Queen's contiguity\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\n\n\n\n\n\nUse the plot() function\n\nThe shape of the markers: The plot markers are by default small, empty circles. These are also known as plot characters - denoted by pch. Pch values 0 to 25 are valid and give several different symbols on the graph. Pch 0 is for a square, 1 is for a circle, 3 is for a triangle, 4 is for a cross and so on.\nSize of the plot markers: The cex parameter can be set to 0.5 if we want the markers to be 50% smaller and 1.5 if wewant them to be 50% larger.\nColor of the plot markers: These colors can be selected from a list provided by R under the colors() function.\n\n\n\n\n8.5.3.2 Plotting Rook contiguity based neighbours map\n\nplot(hunan$geometry, border = 'lightgrey', main='Rooks contiguity')\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col =\"blue\")\n\n\n\n\n\n\n8.5.3.3 Plotting both Queen and Rook contiguity based neighbours maps side-by-side\npar(mfrow = c(1, 2)) arranges subsequent plots in a grid with one row and two columns\n\npar(mfrow=c(1,2))\n\nplot(hunan$geometry, border=\"lightgrey\", main=\"Queen's contiguity\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\", main=\"Queen Contiguity\")\nplot(hunan$geometry, border=\"lightgrey\",main=\"Rook's contiguity\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"blue\", main=\"Rook Contiguity\")"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_1.html#theories",
    "href": "Hands-on_Ex2/Hands-on_Ex2_1.html#theories",
    "title": "Hands-on Exercise 2.1: Spatial Weights and Applications",
    "section": "Theories",
    "text": "Theories"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_2.html#getting-started",
    "href": "Hands-on_Ex2/Hands-on_Ex2_2.html#getting-started",
    "title": "Hands-on Exercise 2.2: Global Measures of Spatial Autocorrelation",
    "section": "Getting Started",
    "text": "Getting Started\n\n\nShow the code\npacman::p_load(sf, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_2.html#learning-outcome",
    "href": "Hands-on_Ex2/Hands-on_Ex2_2.html#learning-outcome",
    "title": "Hands-on Exercise 2.2: Global Measures of Spatial Autocorrelation",
    "section": "1.1 Learning Outcome",
    "text": "1.1 Learning Outcome"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_2.html#importing-geospatial-data",
    "href": "Hands-on_Ex2/Hands-on_Ex2_2.html#importing-geospatial-data",
    "title": "Hands-on Exercise 2.2: Global Measures of Spatial Autocorrelation",
    "section": "Importing Geospatial data",
    "text": "Importing Geospatial data"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_2.html#theories",
    "href": "Hands-on_Ex2/Hands-on_Ex2_2.html#theories",
    "title": "Hands-on Exercise 2.2: Global Measures of Spatial Autocorrelation",
    "section": "Theories",
    "text": "Theories"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_3.html#getting-started",
    "href": "Hands-on_Ex2/Hands-on_Ex2_3.html#getting-started",
    "title": "Hands-on Exercise 2.3:Local Measures of Spatial Autocorrelation",
    "section": "Getting Started",
    "text": "Getting Started\n\n\nShow the code\npacman::p_load(sf, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_3.html#learning-outcome",
    "href": "Hands-on_Ex2/Hands-on_Ex2_3.html#learning-outcome",
    "title": "Hands-on Exercise 2.3:Local Measures of Spatial Autocorrelation",
    "section": "1.1 Learning Outcome",
    "text": "1.1 Learning Outcome"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_3.html#importing-geospatial-data",
    "href": "Hands-on_Ex2/Hands-on_Ex2_3.html#importing-geospatial-data",
    "title": "Hands-on Exercise 2.3:Local Measures of Spatial Autocorrelation",
    "section": "Importing Geospatial data",
    "text": "Importing Geospatial data"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_3.html#theories",
    "href": "Hands-on_Ex2/Hands-on_Ex2_3.html#theories",
    "title": "Hands-on Exercise 2.3:Local Measures of Spatial Autocorrelation",
    "section": "Theories",
    "text": "Theories"
  },
  {
    "objectID": "In-class_Ex1/data/geospatial/MPSZ-2019/MPSZ-2019.html",
    "href": "In-class_Ex1/data/geospatial/MPSZ-2019/MPSZ-2019.html",
    "title": "NYX Geospatial App",
    "section": "",
    "text": "<!DOCTYPE qgis PUBLIC ‘http://mrcc.com/qgis.dtd’ ‘SYSTEM’>     dataset\n\n\n        0 0     false"
  },
  {
    "objectID": "In-class_Ex1/In-class_Ex1.html",
    "href": "In-class_Ex1/In-class_Ex1.html",
    "title": "In-class Exercise 1",
    "section": "",
    "text": "The code chunk below loads the following packages:\n\ntmap: for thematic mapping\nsf: for geospatial data handling\ntidyverse: for non spatial data handling\n\n\npacman::p_load(sf, tmap, tidyverse, knitr)\n\n\n\nFirstly we will import the Passenger volume by Origin Destination Bus Stops dataset downloaded from the LTA Datamall by using the read_csv() of the readr package (to read text data).\n\nodbus_aug <- read_csv(\"data\\\\aspatial\\\\origin_destination_bus_202308.csv\")\n\nConverting character data type to factor data type.\n\nodbus_aug$ORIGIN_PT_CODE <- as.factor(odbus_aug$ORIGIN_PT_CODE)\nodbus_aug$DESTINATION_PT_CODE <- as.factor(odbus_aug$DESTINATION_PT_CODE)\n\nDerive a new field called TRIPS .\n22009: Boon Lay\n46009: Woodlands interchange\n75009: Tampines interchange\nBetter to have a map\n\norigtrip_7_9 <- odbus_aug %>% \n  filter(DAY_TYPE == 'WEEKDAY') %>% \n  filter(TIME_PER_HOUR >= 7 &\n           TIME_PER_HOUR <= 9) %>% \n  group_by(ORIGIN_PT_CODE) %>% \n  summarise(TRIPS = sum(TOTAL_TRIPS))\n\norigtrip_7_9 %>% arrange(desc(TRIPS))\n\n# A tibble: 5,015 × 2\n   ORIGIN_PT_CODE  TRIPS\n   <fct>           <dbl>\n 1 22009          295128\n 2 46009          232902\n 3 75009          134781\n 4 52009          121422\n 5 55509          113434\n 6 24009          108437\n 7 65199          100791\n 8 59009           92333\n 9 84009           88092\n10 54261           86565\n# ℹ 5,005 more rows\n\n\n\n\n\nTwo geospatial data will be used in this exercise.\n\n\n\nbustop <- st_read(dsn=\"data\\\\geospatial\\\\BusStopLocation\\\\BusStopLocation_Jul2023\", layer = \"BusStop\") %>% \n  st_transform(crs = 3414)\n\nReading layer `BusStop' from data source \n  `C:\\yixin-neo\\ISSS624_AGA\\In-class_Ex1\\data\\geospatial\\BusStopLocation\\BusStopLocation_Jul2023' \n  using driver `ESRI Shapefile'\nSimple feature collection with 5161 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3970.122 ymin: 26482.1 xmax: 48284.56 ymax: 52983.82\nProjected CRS: SVY21\n\n\n\n\n\nLoad the geospatial data of basemap from gov.sg , usually in WSG84 format\n\nmpsz <- st_read(dsn=\"data\\\\geospatial\\\\MPSZ-2019\", layer='MPSZ-2019')  %>% \n  st_transform(crs = 3414)\n\nReading layer `MPSZ-2019' from data source \n  `C:\\yixin-neo\\ISSS624_AGA\\In-class_Ex1\\data\\geospatial\\MPSZ-2019' \n  using driver `ESRI Shapefile'\nSimple feature collection with 332 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 103.6057 ymin: 1.158699 xmax: 104.0885 ymax: 1.470775\nGeodetic CRS:  WGS 84\n\nmpsz\n\nSimple feature collection with 332 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\nFirst 10 features:\n                 SUBZONE_N SUBZONE_C       PLN_AREA_N PLN_AREA_C       REGION_N\n1              MARINA EAST    MESZ01      MARINA EAST         ME CENTRAL REGION\n2         INSTITUTION HILL    RVSZ05     RIVER VALLEY         RV CENTRAL REGION\n3           ROBERTSON QUAY    SRSZ01  SINGAPORE RIVER         SR CENTRAL REGION\n4  JURONG ISLAND AND BUKOM    WISZ01  WESTERN ISLANDS         WI    WEST REGION\n5             FORT CANNING    MUSZ02           MUSEUM         MU CENTRAL REGION\n6         MARINA EAST (MP)    MPSZ05    MARINE PARADE         MP CENTRAL REGION\n7                   SUDONG    WISZ03  WESTERN ISLANDS         WI    WEST REGION\n8                  SEMAKAU    WISZ02  WESTERN ISLANDS         WI    WEST REGION\n9           SOUTHERN GROUP    SISZ02 SOUTHERN ISLANDS         SI CENTRAL REGION\n10                 SENTOSA    SISZ01 SOUTHERN ISLANDS         SI CENTRAL REGION\n   REGION_C                       geometry\n1        CR MULTIPOLYGON (((33222.98 29...\n2        CR MULTIPOLYGON (((28481.45 30...\n3        CR MULTIPOLYGON (((28087.34 30...\n4        WR MULTIPOLYGON (((14557.7 304...\n5        CR MULTIPOLYGON (((29542.53 31...\n6        CR MULTIPOLYGON (((35279.55 30...\n7        WR MULTIPOLYGON (((15772.59 21...\n8        WR MULTIPOLYGON (((19843.41 21...\n9        CR MULTIPOLYGON (((30870.53 22...\n10       CR MULTIPOLYGON (((26879.04 26..."
  },
  {
    "objectID": "In-class_Ex2/In-class_Ex2.html",
    "href": "In-class_Ex2/In-class_Ex2.html",
    "title": "In-class Exercise 2:",
    "section": "",
    "text": "#pacman::p_load(sf, tmap, tidyverse)"
  },
  {
    "objectID": "In-class_Ex3/In-class_Ex3.html",
    "href": "In-class_Ex3/In-class_Ex3.html",
    "title": "In-class Exercise 3:",
    "section": "",
    "text": "#pacman::p_load(sf, tmap, tidyverse)"
  },
  {
    "objectID": "In-class_Ex4/In-class_Ex4.html",
    "href": "In-class_Ex4/In-class_Ex4.html",
    "title": "In-class Exercise 4:",
    "section": "",
    "text": "#pacman::p_load(sf, tmap, tidyverse)"
  },
  {
    "objectID": "In-class_Ex5/In-class_Ex5.html",
    "href": "In-class_Ex5/In-class_Ex5.html",
    "title": "In-class Exercise 5:",
    "section": "",
    "text": "#pacman::p_load(sf, tmap, tidyverse)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISSS624_AGA",
    "section": "",
    "text": "Welcome to my Applied Geospatial Analysis Website.\nI will be sharing my learning journey with you."
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_1.html#computing-distance-based-neighbours",
    "href": "Hands-on_Ex2/Hands-on_Ex2_1.html#computing-distance-based-neighbours",
    "title": "Hands-on Exercise 2.1: Spatial Weights and Applications",
    "section": "8.6 Computing distance based neighbours",
    "text": "8.6 Computing distance based neighbours\n\nIn this section, we will derive distance-based weight matrices by using dnearneigh() of spdep package.\ndnearneigh(x, d1, d2, row.names = NULL, longlat = NULL, bounds=c(“GE”, “LE”),\n use_kd_tree=TRUE, symtest=FALSE, use_s2=packageVersion(“s2”) > “1.0.7”, k=200,\n dwithin=TRUE)\nidentifies neighbours using distance band with lower d1= and upper d2= bounds controlled by the bounds= argument\nIf unprojected coordinates are used (WSG84 geographic) and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in km will be calculated assuming the WGS84 reference ellipsoid.\n\n\n8.6.1 Determine the cut-off distance\nFirstly, we need to determine the upper limit for distance band by using the steps below:\n\nReturn a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using knearneigh() of spdep. Class: ‘knn’. Output: NN of poly1 = poly3, NN of poly2 = poly 78 etc…\n\nstr(knearneigh(coords,\n           k=1))\n\nList of 5\n $ nn       : int [1:88, 1] 3 78 1 5 4 69 67 46 84 70 ...\n $ np       : int 88\n $ k        : num 1\n $ dimension: int 2\n $ x        : num [1:88, 1:2] 112 112 112 112 112 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:2] \"longitude\" \"latitude\"\n - attr(*, \"class\")= chr \"knn\"\n - attr(*, \"call\")= language knearneigh(x = coords, k = 1)\n\n#knearneigh(coords,k=1)['nn']  #<< shows matrix\n\nConvert the matrix knn object returned by knearneigh() into a neighbours list with a list of integer vectors containing neighbour region number ids by using knn2nb(). Class: nb\n\nknn2nb(knearneigh(coords))[1:5]\n\n[[1]]\n[1] 3\n\n[[2]]\n[1] 78\n\n[[3]]\n[1] 1\n\n[[4]]\n[1] 5\n\n[[5]]\n[1] 4\n\n\nReturn a list of the length (the distance to one’s nearest neighbour) of neighbour relationship edges by using nbdists() of spdep. The function returns in the units of the coordinates if the coordinates are projected, in km if in WSG84. Class: ‘nbdist’\n\nnbdists(knn2nb(knearneigh(coords, k=1)),\n        coords,\n        longlat = TRUE) [1:5]\n\n[[1]]\n[1] 25.53398\n\n[[2]]\n[1] 43.03114\n\n[[3]]\n[1] 25.53398\n\n[[4]]\n[1] 29.2848\n\n[[5]]\n[1] 29.2848\n\n\nRemove the list structure of the returned object by using unlist(). Class of k1dists: numeric.\nOutput: 25.53398 43.03114 25.53398 29.28480 29.28480 45.98097 58.52704 28.95985 34.45062 37.99885 44.49442 33.48816 35.98123\n\nk1 <- knn2nb(knearneigh(coords, k=1))\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\n\nThe summary report shows that the largest first nearest neighbour distance is 61.79. So using this as the upper threshold (62km) will help to ensure that all units (polygons) will have at least one neighbour.\n\n\n8.6.2 Computing fixed distance weight matrix\n(Earlier, we had used poly2nb(hunan, queen=TRUE/FALSE) to define neighbours using Queen or Rook method, resulting in wm_q and wm_r)\nNow, to define neighbours using distance, we use the dnearneigh() ,\n\nlonglat argument: TRUE if point coordinates are geographical longitude-latitude decimal degrees (WSG84)\n\n\nwm_d62 <- dnearneigh(coords, 0, 62, longlat=TRUE )\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\nAverage number of links is calculated by dividing the total number of links by the number of regions. On average, each region has approximately 3.68 neighboring regions. Class of wm_d62: ‘nb’\n\nclass(wm_d62)\n\n[1] \"nb\"\n\n\nNext, we will use str() to display the content of wm_d62 weight matrix.\n\nstr(wm_d62)\n\nList of 88\n $ : int [1:5] 3 4 5 57 64\n $ : int [1:4] 57 58 78 85\n $ : int [1:4] 1 4 5 57\n $ : int [1:3] 1 3 5\n $ : int [1:4] 1 3 4 85\n $ : int 69\n $ : int [1:2] 67 84\n $ : int [1:4] 9 46 47 78\n $ : int [1:4] 8 46 68 84\n $ : int [1:4] 16 22 70 72\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:2] 11 17\n $ : int 13\n $ : int [1:4] 10 17 22 83\n $ : int [1:3] 11 14 16\n $ : int [1:3] 20 22 63\n $ : int [1:5] 20 21 73 74 82\n $ : int [1:5] 18 19 21 22 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:4] 10 16 18 20\n $ : int [1:3] 41 77 82\n $ : int [1:4] 25 28 31 54\n $ : int [1:4] 24 28 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:2] 26 29\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:2] 27 37\n $ : int 33\n $ : int [1:2] 24 36\n $ : int 50\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:5] 31 34 45 56 80\n $ : int [1:2] 29 42\n $ : int [1:3] 44 77 79\n $ : int [1:4] 40 42 43 81\n $ : int [1:3] 39 45 79\n $ : int [1:5] 23 35 45 79 82\n $ : int [1:5] 26 37 39 43 81\n $ : int [1:3] 39 42 44\n $ : int [1:2] 38 43\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:5] 8 9 35 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:4] 48 49 50 52\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:2] 48 55\n $ : int [1:5] 24 28 49 50 52\n $ : int [1:4] 48 50 53 75\n $ : int 36\n $ : int [1:5] 1 2 3 58 64\n $ : int [1:5] 2 57 64 66 68\n $ : int [1:3] 60 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:5] 12 60 62 63 87\n $ : int [1:4] 61 63 77 87\n $ : int [1:5] 12 18 61 62 83\n $ : int [1:4] 1 57 58 76\n $ : int 76\n $ : int [1:5] 58 67 68 76 84\n $ : int [1:2] 7 66\n $ : int [1:4] 9 58 66 84\n $ : int [1:2] 6 75\n $ : int [1:3] 10 72 73\n $ : int [1:2] 73 74\n $ : int [1:3] 10 11 70\n $ : int [1:4] 19 70 71 74\n $ : int [1:5] 19 21 71 73 86\n $ : int [1:2] 55 69\n $ : int [1:3] 64 65 66\n $ : int [1:3] 23 38 62\n $ : int [1:2] 2 8\n $ : int [1:4] 38 40 41 45\n $ : int [1:5] 34 35 36 45 47\n $ : int [1:5] 25 26 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:4] 12 13 16 63\n $ : int [1:4] 7 9 66 68\n $ : int [1:2] 2 5\n $ : int [1:4] 21 46 47 74\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 62, longlat = TRUE)\n - attr(*, \"dnn\")= num [1:2] 0 62\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE\n\n\nAnother way to display the structure of the weight matrix is to combine table() and card() of spdep.\nThe column headers “1” means the count of counties that have 1 neighbor within the specified distance of 62km, “2” means the count of counties that have 2 neighbors, and so on.\n\ntable(hunan$County, card(wm_d62))\n\n               \n                1 2 3 4 5 6\n  Anhua         1 0 0 0 0 0\n  Anren         0 0 0 1 0 0\n  Anxiang       0 0 0 0 1 0\n  Baojing       0 0 0 0 1 0\n  Chaling       0 0 1 0 0 0\n  Changning     0 0 1 0 0 0\n  Changsha      0 0 0 1 0 0\n  Chengbu       0 1 0 0 0 0\n  Chenxi        0 0 0 1 0 0\n  Cili          0 1 0 0 0 0\n  Dao           0 0 0 1 0 0\n  Dongan        0 0 1 0 0 0\n  Dongkou       0 0 0 1 0 0\n  Fenghuang     0 0 0 1 0 0\n  Guidong       0 0 1 0 0 0\n  Guiyang       0 0 0 1 0 0\n  Guzhang       0 0 0 0 0 1\n  Hanshou       0 0 0 1 0 0\n  Hengdong      0 0 0 0 1 0\n  Hengnan       0 0 0 0 1 0\n  Hengshan      0 0 0 0 0 1\n  Hengyang      0 0 0 0 0 1\n  Hongjiang     0 0 0 0 1 0\n  Huarong       0 0 0 1 0 0\n  Huayuan       0 0 0 1 0 0\n  Huitong       0 0 0 1 0 0\n  Jiahe         0 0 0 0 1 0\n  Jianghua      0 0 1 0 0 0\n  Jiangyong     0 1 0 0 0 0\n  Jingzhou      0 1 0 0 0 0\n  Jinshi        0 0 0 1 0 0\n  Jishou        0 0 0 0 0 1\n  Lanshan       0 0 0 1 0 0\n  Leiyang       0 0 0 1 0 0\n  Lengshuijiang 0 0 1 0 0 0\n  Li            0 0 1 0 0 0\n  Lianyuan      0 0 0 0 1 0\n  Liling        0 1 0 0 0 0\n  Linli         0 0 0 1 0 0\n  Linwu         0 0 0 1 0 0\n  Linxiang      1 0 0 0 0 0\n  Liuyang       0 1 0 0 0 0\n  Longhui       0 0 1 0 0 0\n  Longshan      0 1 0 0 0 0\n  Luxi          0 0 0 0 1 0\n  Mayang        0 0 0 0 0 1\n  Miluo         0 0 0 0 1 0\n  Nan           0 0 0 0 1 0\n  Ningxiang     0 0 0 1 0 0\n  Ningyuan      0 0 0 0 1 0\n  Pingjiang     0 1 0 0 0 0\n  Qidong        0 0 1 0 0 0\n  Qiyang        0 0 1 0 0 0\n  Rucheng       0 1 0 0 0 0\n  Sangzhi       0 1 0 0 0 0\n  Shaodong      0 0 0 0 1 0\n  Shaoshan      0 0 0 0 1 0\n  Shaoyang      0 0 0 1 0 0\n  Shimen        1 0 0 0 0 0\n  Shuangfeng    0 0 0 0 0 1\n  Shuangpai     0 0 0 1 0 0\n  Suining       0 0 0 0 1 0\n  Taojiang      0 1 0 0 0 0\n  Taoyuan       0 1 0 0 0 0\n  Tongdao       0 1 0 0 0 0\n  Wangcheng     0 0 0 1 0 0\n  Wugang        0 0 1 0 0 0\n  Xiangtan      0 0 0 1 0 0\n  Xiangxiang    0 0 0 0 1 0\n  Xiangyin      0 0 0 1 0 0\n  Xinhua        0 0 0 0 1 0\n  Xinhuang      1 0 0 0 0 0\n  Xinning       0 1 0 0 0 0\n  Xinshao       0 0 0 0 0 1\n  Xintian       0 0 0 0 1 0\n  Xupu          0 1 0 0 0 0\n  Yanling       0 0 1 0 0 0\n  Yizhang       1 0 0 0 0 0\n  Yongshun      0 0 0 1 0 0\n  Yongxing      0 0 0 1 0 0\n  You           0 0 0 1 0 0\n  Yuanjiang     0 0 0 0 1 0\n  Yuanling      1 0 0 0 0 0\n  Yueyang       0 0 1 0 0 0\n  Zhijiang      0 0 0 0 1 0\n  Zhongfang     0 0 0 1 0 0\n  Zhuzhou       0 0 0 0 1 0\n  Zixing        0 0 1 0 0 0\n\n\nTO find the number of connected components (aka see if there are any spatial units / regions without a neighbour)\n\nn_comp <- n.comp.nb(wm_d62)\nn_comp$nc\n\n[1] 1\n\n\nIn this connected component, there are 88 elements (spatial units)\n\ntable(n_comp$comp.id)\n\n\n 1 \n88 \n\n\n\n8.6.2.1 Plotting fixed distance weight matrix\nNext, we will plot the distance weight matrix by using the code chunk below.\n\nwm_d62 is the fixed distance weight matrix,\ncoords refers to long, lat coordinates for CG of each polygon\nk1 is the list of integer ID of the polygon which is the nearest neighbour to me. The topmost layer of the plot colours the nearest neighbour edge to red colour.\n\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_d62, coords, add=TRUE)\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08) \n\n\n\n\nThe red lines shows the links of 1st nearest neighbours and the black lines show the lines of neighbours within the cut-off distance of 62km.\nTo plot red and black side by side,\n\npar(mfrow = c(1, 2))\nplot(hunan$geometry, border=\"lightgrey\", main = 'Neighbours within 62 km')\nplot(wm_d62, coords, add=TRUE)\nplot(hunan$geometry, border=\"lightgrey\", main = 'Nearest Neighbour')\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08) \n\n\n\n\n\n\n\n8.6.3 Computing adaptive distance weight matrix\nUse this method if the dataset is highly skewed to fix the # of nbs.\nEarlier, we used k1 <- knn2nb(knearneigh(coords, k=1)) and wm_d62 <- dnearneigh(coords, 0, 62, longlat=TRUE ) to plot maps of nearest nb and nbs within 62km range.\nOne of the characteristics of fixed distance weight matrix is that more densely settled areas (usually the urban areas) tend to have more neighbours and the less densely settled areas (usually the rural counties) tend to have lesser neighbours. Having many neighbours smoothes the neighbour relationship across more neighbours.\nIt is possible to control the numbers of neighbours directly using k-nearest neighbours, either accepting asymmetric neighbours or imposing symmetry as shown in the code chunk below. class of knn6: ‘nb’\n\nknn6 <- knn2nb(knearneigh(coords, k=6))\nknn6\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 528 \nPercentage nonzero weights: 6.818182 \nAverage number of links: 6 \nNon-symmetric neighbours list\n\n\nSimilarly, we can display the content of the matrix by using str(). Note that each spatial units has exactly 6 neighbours.\n\nstr(knn6)\n\nList of 88\n $ : int [1:6] 2 3 4 5 57 64\n $ : int [1:6] 1 3 57 58 78 85\n $ : int [1:6] 1 2 4 5 57 85\n $ : int [1:6] 1 3 5 6 69 85\n $ : int [1:6] 1 3 4 6 69 85\n $ : int [1:6] 3 4 5 69 75 85\n $ : int [1:6] 9 66 67 71 74 84\n $ : int [1:6] 9 46 47 78 80 86\n $ : int [1:6] 8 46 66 68 84 86\n $ : int [1:6] 16 19 22 70 72 73\n $ : int [1:6] 10 14 16 17 70 72\n $ : int [1:6] 13 15 60 61 63 83\n $ : int [1:6] 12 15 60 61 63 83\n $ : int [1:6] 11 15 16 17 72 83\n $ : int [1:6] 12 13 14 17 60 83\n $ : int [1:6] 10 11 17 22 72 83\n $ : int [1:6] 10 11 14 16 72 83\n $ : int [1:6] 20 22 23 63 77 83\n $ : int [1:6] 10 20 21 73 74 82\n $ : int [1:6] 18 19 21 22 23 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:6] 10 16 18 19 20 83\n $ : int [1:6] 18 20 41 77 79 82\n $ : int [1:6] 25 28 31 52 54 81\n $ : int [1:6] 24 28 31 33 54 81\n $ : int [1:6] 25 27 29 33 42 81\n $ : int [1:6] 26 29 30 37 42 81\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:6] 26 27 37 42 43 81\n $ : int [1:6] 26 27 28 33 49 81\n $ : int [1:6] 24 25 36 39 40 54\n $ : int [1:6] 24 31 50 54 55 56\n $ : int [1:6] 25 26 28 30 49 81\n $ : int [1:6] 36 40 41 45 56 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:6] 26 27 29 42 43 44\n $ : int [1:6] 23 43 44 62 77 79\n $ : int [1:6] 25 40 42 43 44 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:6] 26 27 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:6] 37 38 39 42 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:6] 8 9 35 47 78 86\n $ : int [1:6] 8 21 35 46 80 86\n $ : int [1:6] 49 50 51 52 53 55\n $ : int [1:6] 28 33 48 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:6] 28 48 49 50 52 54\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:6] 48 50 51 52 55 75\n $ : int [1:6] 24 28 49 50 51 52\n $ : int [1:6] 32 48 50 52 53 75\n $ : int [1:6] 32 34 36 78 80 85\n $ : int [1:6] 1 2 3 58 64 68\n $ : int [1:6] 2 57 64 66 68 78\n $ : int [1:6] 12 13 60 61 87 88\n $ : int [1:6] 12 13 59 61 63 87\n $ : int [1:6] 12 13 60 62 63 87\n $ : int [1:6] 12 38 61 63 77 87\n $ : int [1:6] 12 18 60 61 62 83\n $ : int [1:6] 1 3 57 58 68 76\n $ : int [1:6] 58 64 66 67 68 76\n $ : int [1:6] 9 58 67 68 76 84\n $ : int [1:6] 7 65 66 68 76 84\n $ : int [1:6] 9 57 58 66 78 84\n $ : int [1:6] 4 5 6 32 75 85\n $ : int [1:6] 10 16 19 22 72 73\n $ : int [1:6] 7 19 73 74 84 86\n $ : int [1:6] 10 11 14 16 17 70\n $ : int [1:6] 10 19 21 70 71 74\n $ : int [1:6] 19 21 71 73 84 86\n $ : int [1:6] 6 32 50 53 55 69\n $ : int [1:6] 58 64 65 66 67 68\n $ : int [1:6] 18 23 38 61 62 63\n $ : int [1:6] 2 8 9 46 58 68\n $ : int [1:6] 38 40 41 43 44 45\n $ : int [1:6] 34 35 36 41 45 47\n $ : int [1:6] 25 26 28 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:6] 12 13 15 16 22 63\n $ : int [1:6] 7 9 66 68 71 74\n $ : int [1:6] 2 3 4 5 56 69\n $ : int [1:6] 8 9 21 46 47 74\n $ : int [1:6] 59 60 61 62 63 88\n $ : int [1:6] 59 60 61 62 63 87\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language knearneigh(x = coords, k = 6)\n - attr(*, \"sym\")= logi FALSE\n - attr(*, \"type\")= chr \"knn\"\n - attr(*, \"knn-k\")= num 6\n - attr(*, \"class\")= chr \"nb\"\n\n\n\n8.6.3.1 Plotting distance based neighbours\n\nplot(st_geometry(hunan), border = 'lightgray')\nplot(knn6, coords, pch=18, cex=0.6, add= TRUE, col='red')"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_1.html#weights-based-on-inverse-distance-method",
    "href": "Hands-on_Ex2/Hands-on_Ex2_1.html#weights-based-on-inverse-distance-method",
    "title": "Hands-on Exercise 2.1: Spatial Weights and Applications",
    "section": "8.7 Weights based on Inverse Distance Method",
    "text": "8.7 Weights based on Inverse Distance Method\nIn this section, we will learn how to derive a spatial weight matrix based on Inversed Distance method. This will assign greater weightage to closer polygons, use this if we know that closer proximity will result in more spatial interaction.\nEarlier, we applied nbdists() nbdists(knn2nb(knearneigh(coords, k=1)), coords, longlat = TRUE) to compute the distance of one’s nearest neighbour.\nFirst, we will compute the distances between areas (defined using Queen contiguity method) by using nbdists() of spdep.\n\nQueen’s neighbours distanceFixed’s neighbours distance (NYX)\n\n\n\ndist <- nbdists(wm_q, coords, longlat=TRUE)\nhead(dist,3)\n\n[[1]]\n[1] 65.12941 25.53398 54.91802 35.61352 87.32760\n\n[[2]]\n[1] 65.12941 56.67944 51.92312 43.03114 58.16151\n\n[[3]]\n[1] 25.53398 35.43536 27.05778 71.64530\n\n\n\n\n\nhead(nbdists(wm_d62, coords, longlat=TRUE),3)\n\n[[1]]\n[1] 25.53398 54.91802 52.58627 35.61352 48.15609\n\n[[2]]\n[1] 56.67944 51.92312 43.03114 58.16151\n\n[[3]]\n[1] 25.53398 35.43536 27.05778 58.73243\n\n\n\n\n\nFor queen’s method, now compute the inverse distances for all polygons to their neighbours\n\nids <- lapply(dist, function(x) 1/(x))\nhead(ids,3)\n\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n[[2]]\n[1] 0.01535405 0.01764308 0.01925924 0.02323898 0.01719350\n\n[[3]]\n[1] 0.03916350 0.02822040 0.03695795 0.01395765\n\n\n\n8.7.1 Row-standardised weights matrix\nnb2listw(neighbours, glist=NULL, style=\"W\", zero.policy=NULL)\nArguments\n\n\n\n\n\n\n\nneighbours\nan object of class nb\n\n\n\n\nglist\nlist of general weights corresponding to neighbours\n\n\nstyle\nstyle can take values “W”, “B”, “C”, “U”, “minmax” and “S”\n\n\nzero.policy\ndefault NULL, use global option value; if FALSE stop with error for any empty neighbour sets, if TRUE permit the weights list to be formed with zero-length weights vectors\n\n\n\nDetails\nStarting from a binary neighbours list, in which regions are either listed as neighbours or are absent (thus not in the set of neighbours for some definition), the function adds a weights list with values given by the coding scheme style chosen.\nWeights to each neighboring polygon\n\neach neighboring polygon will be assigned equal weight (style=“W”) <- row standardised. This is accomplished by assigning the fraction 1/(#ofneighbors) to each neighboring county then summing the weighted income values\ndrawback of this method is that polygon along the edge will base their lagged values on fewer polygons, thus over estimating the true nature of spatial autocorrelation in the data. Next time can consider other more robust options are available, notably style=“B” <- basic binary coding\nThe zero.policy=TRUE option allows for lists of non-neighbors. This should be used with caution since the user may not be aware of missing neighbors in their dataset however, a zero.policy of FALSE would return an error. Class of rsmq_q = ‘listw’ and ‘nb’\n\n\n# wm_q is binary matrix\nrswm_q <- nb2listw(wm_q, style = 'W', zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\n\nclass(rswm_q)\n\n[1] \"listw\" \"nb\"   \n\n\nTo see the weight of the first polygon’s 5 neighbours type:\n\nrswm_q$weights[1]\n\n[[1]]\n[1] 0.2 0.2 0.2 0.2 0.2\n\n\nThe 5 neighbours are\n\nrswm_q$neighbours[1]\n\n[[1]]\n[1]  2  3  4 57 85\n\n\nExplanation of above: Each neighbor is assigned a 0.125 of the total weight. This means that when R computes the average neighboring income values, each neighbor’s income will be multiplied by 0.125 before being tallied.\nUsing the same queen’s method, we can also derive a row standardised inverse-distance weight matrix by using the code chunk below. Recall ids contains inverse-distances to neighbours , originally from queens wm_q which is a binary matrix. Class of rswm_q is ‘listw’ and ‘nb’\n\nrswm_ids <- nb2listw(wm_q, glist=ids, style ='B', zero.policy=TRUE)\nrswm_ids\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn       S0        S1     S2\nB 88 7744 8.786867 0.3776535 3.8137\n\n\nTo see the weights of the 1st polygon; it is actually the same as ids\n\nrswm_ids$weights[1]\n\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n\n\nsummary(unlist(rswm_ids$weights))\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n0.008218 0.015088 0.018739 0.019614 0.022823 0.040338"
  },
  {
    "objectID": "Hands-on_Ex2/Hands-on_Ex2_1.html#application-of-spatial-weight-matrix",
    "href": "Hands-on_Ex2/Hands-on_Ex2_1.html#application-of-spatial-weight-matrix",
    "title": "Hands-on Exercise 2.1: Spatial Weights and Applications",
    "section": "8.8 Application of Spatial Weight Matrix",
    "text": "8.8 Application of Spatial Weight Matrix\nIn this section, you will learn how to create four different spatial lagged variables, they are:\n\nspatial lag with row-standardized weights,\nspatial lag as a sum of neighbouring values,\nspatial window average, and\nspatial window sum.\n\n\n8.8.1 Spatial lag with row-standardized weights\n\ncompute the average neighbour GDPCC values for each polygon\ncommonly called spatially lagged values\ndoes not include itself\nRecalled in the previous section, we retrieved the GDPPC of these five countries (neighbours of poly1 using queen method) by using the code chunk below.\n\n\nx1 <- wm_q[[1]]\nhunan$GDPPC[c(x1)]\n\n[1] 20981 34592 24473 21311 22879\n\n\n\nIn the code below, use spatial weight matrix (equal weightage of 0.2 for poly1 etc.. ) by 0.2 * 20981 + 0.2 * 34592 + 0.2 * 24473 + 0.2 * 21311 + 0.2 * 22879 = 24847.20 for poly1 “Anxiang”\n22724.80 is the average GDPPC for poly2 based on equal weightage (0.2) of all its five neighbours . 24143.25 for poly3 based on equal weightage (0.25) based on four neighbours.\n\n\nGDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)\nGDPPC.lag\n\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n\n\nWe can append the spatially lag GDPPC values onto hunan sf data frame by using the code chunk below.\nFirst, create lag.list that contains two individual lists, namely NAME_3 column in hunan and the lag variable. Next, transform both lists into a dataframe. Rename the column headers. Perform a left join with hunan and lag.res will automatically use NAME_3 column as the join column.\n\nlag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))\nlag.res <- as.data.frame(lag.list)\ncolnames(lag.res) <- c(\"NAME_3\", \"lag GDPPC\")\nhunan <- left_join(hunan,lag.res)\n\nThe following table shows the average neighboring income values (stored in the Inc.lag object) for each county.\n\nhead(hunan,3)\n\nSimple feature collection with 3 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 111.7027 ymin: 28.61762 xmax: 112.3013 ymax: 29.77344\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3  County GDPPC lag GDPPC\n1 Changde 21098 Anxiang      County Anxiang 23667  24847.20\n2 Changde 21100 Hanshou      County Hanshou 20981  22724.80\n3 Changde 21101  Jinshi County City  Jinshi 34592  24143.25\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n\n\nNext, we will plot both the GDPPC and spatial lag GDPPC for comparison using the code chunk below.\n\ngdppc <- qtm(hunan, 'GDPPC') +\n    tm_layout(legend.height = 0.2,\n              legend.width=0.2)\nlag_gdppc <- qtm(hunan, 'lag GDPPC') +\n  tm_layout(legend.height = 0.2,\n            legend.width=0.4)\n\ntmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)"
  }
]