{
  "hash": "d99a2e9b74999c61f724f823267d61dd",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Exercise 2.1: Spatial Weights and Applications\"\nauthor: \"NeoYX\"\ndate: '20 Nov 2023'\ndate-modified: \"2023-11-20\"\neditor: visual\nexecute: \n  freeze: auto\n  warning: false\n  #echo: false\n  #message: false\nformat: \n  html:\n    code-fold: false\n    code-overflow: scroll\n    code-summary: \"Show the code\"\n    code-line-numbers: true\n---\n\n\n## **8.1 Overview**\n\nIn this hands-on exercise, we will learn how to compute spatial weights using R. By the end to this hands-on exercise, we will be able to:\n\n-   import geospatial data using appropriate function(s) of **sf** package,\n\n-   import csv file using appropriate function of **readr** package,\n\n-   perform relational join using appropriate join function of **dplyr** package,\n\n-   compute spatial weights using appropriate functions of **spdep** package, and\n\n-   calculate spatially lagged variables using appropriate functions of **spdep** package.\n\n## **8.2 The Study Area and Data**\n\nTwo data sets will be used in this hands-on exercise, they are:\n\n-   Hunan county boundary layer. This is a geospatial data set in ESRI shapefile format.\n\n-   Hunan_2012.csv: This csv file (aspatial) contains selected Hunan's local development indicators in 2012.\n\n### **8.2.1 Getting Started**\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse, knitr)\n```\n:::\n\n\n## **8.3 Getting the Data Into R Environment**\n\n**8.3.1 Import shapefile into r environment**\n\nThe code chunk below uses [*st_read()*](https://r-spatial.github.io/sf/reference/st_read.html) of **sf** package to import Hunan shapefile into R. The imported shapefile will be **simple features** Object of **sf**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn='data/geospatial',\n                 layer = 'Hunan')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Hunan' from data source \n  `C:\\yixin-neo\\ISSS624_AGA\\Hands-on_Ex2\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n\n```{.r .cell-code}\nclass(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"data.frame\"\n```\n:::\n:::\n\n\n`hunan` is in WSG84 coordinate system.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hunan,3) %>% kable()\n```\n\n::: {.cell-output-display}\n|NAME_2  |  ID_3|NAME_3  |ENGTYPE_3   | Shape_Leng| Shape_Area|County  |geometry                       |\n|:-------|-----:|:-------|:-----------|----------:|----------:|:-------|:------------------------------|\n|Changde | 21098|Anxiang |County      |   1.869074|  0.1005619|Anxiang |POLYGON ((112.0625 29.75523... |\n|Changde | 21100|Hanshou |County      |   2.360691|  0.1997875|Hanshou |POLYGON ((112.2288 29.11684... |\n|Changde | 21101|Jinshi  |County City |   1.425620|  0.0530241|Jinshi  |POLYGON ((111.8927 29.6013,... |\n:::\n:::\n\n\n### **8.3.2 Import csv file into r environment**\n\nNext, we will import *Hunan_2012.csv* into R by using *read_csv()* of **readr** package. The output is R dataframe class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv('data/aspatial/Hunan_2012.csv')\nhead(hunan2012,3) %>% kable()\n```\n\n::: {.cell-output-display}\n|County  |City     | avg_wage| deposite|    FAI| Gov_Rev| Gov_Exp|     GDP| GDPPC|    GIO|   Loan|  NIPCR|  Bed|    Emp|  EmpR| EmpRT| Pri_Stu| Sec_Stu| Household| Household_R| NOIP| Pop_R|   RSCG| Pop_T|     Agri| Service| Disp_Inc|      RORP|    ROREmp|\n|:-------|:--------|--------:|--------:|------:|-------:|-------:|-------:|-----:|------:|------:|------:|----:|------:|-----:|-----:|-------:|-------:|---------:|-----------:|----:|-----:|------:|-----:|--------:|-------:|--------:|---------:|---------:|\n|Anhua   |Yiyang   |    30544|  10967.0| 6831.7|  456.72|  2703.0| 13225.0| 14567| 9276.9| 3954.9| 3528.3| 2718| 494.31| 441.4| 338.0|  54.175|  32.830|     290.4|       234.5|  101| 670.3| 5760.6| 910.8| 4942.253|  5414.5|    12373| 0.7359464| 0.8929619|\n|Anren   |Chenzhou |    28058|   4598.9| 6386.1|  220.57|  1454.7|  4941.2| 12761| 4189.2| 2555.3| 3271.8|  970| 290.82| 255.4|  99.4|  33.171|  17.505|     104.6|       121.9|   34| 243.2| 2386.4| 388.7| 2357.764|  3814.1|    16072| 0.6256753| 0.8782065|\n|Anxiang |Changde  |    31935|   5517.2| 3541.0|  243.64|  1779.5| 12482.0| 23667| 5108.9| 2806.9| 7693.7| 1931| 336.39| 270.5| 205.9|  19.584|  17.819|     148.1|       135.4|   53| 346.0| 3957.9| 528.3| 4524.410| 14100.0|    16610| 0.6549309| 0.8041262|\n:::\n:::\n\n\n### **8.3.3 Performing relational join**\n\nThe code chunk below will be used to update the attribute table of *hunan*'s SpatialPolygonsDataFrame with the attribute fields of *hunan2012* dataframe. This is performed by using *left_join()* of **dplyr** package.\n\nAs the join columns are not specified, this function will assume that columns with the same names, e.g., 'county' in both dfs will be the join columns.\n\nThe select() will retain the columns indicated in the resulting joined df.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, hunan2012) %>% \n  select(1:4,7,15)\nclass(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"data.frame\"\n```\n:::\n:::\n\n\nNote the geospatial characteristics of hunan is retained.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hunan,3) %>% kable\n```\n\n::: {.cell-output-display}\n|NAME_2  |  ID_3|NAME_3  |ENGTYPE_3   |County  | GDPPC|geometry                       |\n|:-------|-----:|:-------|:-----------|:-------|-----:|:------------------------------|\n|Changde | 21098|Anxiang |County      |Anxiang | 23667|POLYGON ((112.0625 29.75523... |\n|Changde | 21100|Hanshou |County      |Hanshou | 20981|POLYGON ((112.2288 29.11684... |\n|Changde | 21101|Jinshi  |County City |Jinshi  | 34592|POLYGON ((111.8927 29.6013,... |\n:::\n:::\n\n\n## **8.4 Visualising Regional Development Indicator**\n\nNow, we are going to prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using *qtm()* of **tmap** package.\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nbasemap <- tm_shape(hunan)+\n  tm_polygons() +\n  tm_text('NAME_3',\n          size = 0.35)\n\ngdppc <- tm_shape(hunan)+\n  tm_polygons('GDPPC') +\n    tm_layout(legend.height = 0.20, \n            legend.width = 0.25)\n  \n\ntmap_arrange(basemap, gdppc,\n           asp=1,\n           ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-7-1.png){width=1344}\n:::\n:::\n\n\n## **8.5 Computing Contiguity Spatial Weights**\n\nIn this section, we will use [*poly2nb()*](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package to compute contiguity weight matrices for the study area. This function builds a neighbours list based on regions with contiguous boundaries.\n\nBy default, 'queen' argument is set to TRUE: two polygons sharing one shared boundary point will meet contiguity condition. Returns a list of first order neighbours using the Queen criteria.\n\nIf 'queen' argument is set to FALSE: requires more than one shared boundary point. (but may not mean a shared boundary line)\n\n### **8.5.1 Computing (QUEEN) contiguity based neighbours**\n\nThe code chunk below is used to compute Queen contiguity weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n:::\n:::\n\n\nThe summary report above shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours. There are two area units with only one heighbours.\n\n`wm_q` (weights matrix queen) 's class\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"nb\"\n```\n:::\n:::\n\n\nA quick peak at `wm_q`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(wm_q,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1]  2  3  4 57 85\n\n[[2]]\n[1]  1 57 58 78 85\n\n[[3]]\n[1]  1  4  5 85\n```\n:::\n:::\n\n\nFor each polygon in our polygon object, *wm_q* lists all neighboring polygons. For example, to see the neighbors for the first polygon in the object, type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  3  4 57 85\n```\n:::\n:::\n\n\nPolygon 1 has 5 neighbors. The numbers represent the polygon IDs as stored in hunan SpatialPolygonsDataFrame class.\n\nWe can retrive the county name of Polygon ID=1 by using the code chunk below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan$County[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Anxiang\"\n```\n:::\n:::\n\n\nPolygon ID=1 is Anxiang county.\n\nTo reveal the county names of the five neighboring polygons, the code chunk will be used:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- wm_q[[1]]\nhunan$County[c(x1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n```\n:::\n:::\n\n\nThe printed output above shows that the GDPPC of the five nearest neighbours based on Queen\\'s method are 20981, 34592, 24473, 21311 and 22879 respectively.\n\nTo display the complete weight matrix, use *str()*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"sym\")= logi TRUE\n```\n:::\n\n```{.r .cell-code}\n#wm_q[1:10]\n#methods(class = class(wm_q))\n```\n:::\n\n\n### **8.5.2 Creating (ROOK) contiguity based neighbours**\n\nThe code chunk below is used to compute Rook contiguity weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n```\n:::\n:::\n\n\nThe summary report above shows that there are 88 area units in Hunan. The most connect area unit has 10 neighbours. There are two area units with only one heighbours.\n\n\n\n\n\n\n\n\n\n::: {.cell fig.asp='0.68'}\n\n:::\n\n\n## Theories\n\n### \n",
    "supporting": [
      "Hands-on_Ex2_1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}