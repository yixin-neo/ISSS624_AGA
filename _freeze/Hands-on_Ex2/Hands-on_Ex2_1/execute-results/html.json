{
  "hash": "658f5a9597a27326534da07272fd4fba",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Exercise 2.1: Spatial Weights and Applications\"\nauthor: \"NeoYX\"\ndate: '20 Nov 2023'\ndate-modified: \"2023-11-21\"\neditor: visual\nexecute: \n  freeze: auto\n  warning: false\n  #echo: false\n  #message: false\nformat: \n  html:\n    code-fold: false\n    code-overflow: scroll\n    code-summary: \"Show the code\"\n    code-line-numbers: true\n---\n\n\n## **8.1 Overview**\n\nIn this hands-on exercise, we will learn how to compute spatial weights using R. By the end to this hands-on exercise, we will be able to:\n\n-   import geospatial data using appropriate function(s) of **sf** package,\n\n-   import csv file using appropriate function of **readr** package,\n\n-   perform relational join using appropriate join function of **dplyr** package,\n\n-   compute spatial weights using appropriate functions of **spdep** package, and\n\n-   calculate spatially lagged variables using appropriate functions of **spdep** package.\n\n## **8.2 The Study Area and Data**\n\nTwo data sets will be used in this hands-on exercise, they are:\n\n-   Hunan county boundary layer. This is a geospatial data set in ESRI shapefile format.\n\n-   Hunan_2012.csv: This csv file (aspatial) contains selected Hunan's local development indicators in 2012.\n\n### **8.2.1 Getting Started**\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse, knitr)\n```\n:::\n\n\n## **8.3 Getting the Data Into R Environment**\n\n**8.3.1 Import shapefile into r environment**\n\nThe code chunk below uses [*st_read()*](https://r-spatial.github.io/sf/reference/st_read.html) of **sf** package to import Hunan shapefile into R. The imported shapefile will be **simple features** Object of **sf**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn='data/geospatial',\n                 layer = 'Hunan')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Hunan' from data source \n  `C:\\yixin-neo\\ISSS624_AGA\\Hands-on_Ex2\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n\n```{.r .cell-code}\nclass(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"data.frame\"\n```\n:::\n:::\n\n\n`hunan` is in WSG84 coordinate system.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hunan,3) %>% kable()\n```\n\n::: {.cell-output-display}\n|NAME_2  |  ID_3|NAME_3  |ENGTYPE_3   | Shape_Leng| Shape_Area|County  |geometry                       |\n|:-------|-----:|:-------|:-----------|----------:|----------:|:-------|:------------------------------|\n|Changde | 21098|Anxiang |County      |   1.869074|  0.1005619|Anxiang |POLYGON ((112.0625 29.75523... |\n|Changde | 21100|Hanshou |County      |   2.360691|  0.1997875|Hanshou |POLYGON ((112.2288 29.11684... |\n|Changde | 21101|Jinshi  |County City |   1.425620|  0.0530241|Jinshi  |POLYGON ((111.8927 29.6013,... |\n:::\n:::\n\n\n### **8.3.2 Import csv file into r environment**\n\nNext, we will import *Hunan_2012.csv* into R by using *read_csv()* of **readr** package. The output is R dataframe class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv('data/aspatial/Hunan_2012.csv')\nhead(hunan2012,3) %>% kable()\n```\n\n::: {.cell-output-display}\n|County  |City     | avg_wage| deposite|    FAI| Gov_Rev| Gov_Exp|     GDP| GDPPC|    GIO|   Loan|  NIPCR|  Bed|    Emp|  EmpR| EmpRT| Pri_Stu| Sec_Stu| Household| Household_R| NOIP| Pop_R|   RSCG| Pop_T|     Agri| Service| Disp_Inc|      RORP|    ROREmp|\n|:-------|:--------|--------:|--------:|------:|-------:|-------:|-------:|-----:|------:|------:|------:|----:|------:|-----:|-----:|-------:|-------:|---------:|-----------:|----:|-----:|------:|-----:|--------:|-------:|--------:|---------:|---------:|\n|Anhua   |Yiyang   |    30544|  10967.0| 6831.7|  456.72|  2703.0| 13225.0| 14567| 9276.9| 3954.9| 3528.3| 2718| 494.31| 441.4| 338.0|  54.175|  32.830|     290.4|       234.5|  101| 670.3| 5760.6| 910.8| 4942.253|  5414.5|    12373| 0.7359464| 0.8929619|\n|Anren   |Chenzhou |    28058|   4598.9| 6386.1|  220.57|  1454.7|  4941.2| 12761| 4189.2| 2555.3| 3271.8|  970| 290.82| 255.4|  99.4|  33.171|  17.505|     104.6|       121.9|   34| 243.2| 2386.4| 388.7| 2357.764|  3814.1|    16072| 0.6256753| 0.8782065|\n|Anxiang |Changde  |    31935|   5517.2| 3541.0|  243.64|  1779.5| 12482.0| 23667| 5108.9| 2806.9| 7693.7| 1931| 336.39| 270.5| 205.9|  19.584|  17.819|     148.1|       135.4|   53| 346.0| 3957.9| 528.3| 4524.410| 14100.0|    16610| 0.6549309| 0.8041262|\n:::\n:::\n\n\n### **8.3.3 Performing relational join**\n\nThe code chunk below will be used to update the attribute table of *hunan*'s SpatialPolygonsDataFrame with the attribute fields of *hunan2012* dataframe. This is performed by using *left_join()* of **dplyr** package.\n\nAs the join columns are not specified, this function will assume that columns with the same names, e.g., 'county' in both dfs will be the join columns.\n\nThe select() will retain the columns indicated in the resulting joined df.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, hunan2012) %>% \n  select(1:4,7,15)\nclass(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"data.frame\"\n```\n:::\n:::\n\n\nNote the geospatial characteristics of hunan is retained.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hunan,3) %>% kable\n```\n\n::: {.cell-output-display}\n|NAME_2  |  ID_3|NAME_3  |ENGTYPE_3   |County  | GDPPC|geometry                       |\n|:-------|-----:|:-------|:-----------|:-------|-----:|:------------------------------|\n|Changde | 21098|Anxiang |County      |Anxiang | 23667|POLYGON ((112.0625 29.75523... |\n|Changde | 21100|Hanshou |County      |Hanshou | 20981|POLYGON ((112.2288 29.11684... |\n|Changde | 21101|Jinshi  |County City |Jinshi  | 34592|POLYGON ((111.8927 29.6013,... |\n:::\n:::\n\n\n## **8.4 Visualising Regional Development Indicator**\n\nNow, we are going to prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using *qtm()* of **tmap** package.\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nbasemap <- tm_shape(hunan)+\n  tm_polygons() +\n  tm_text('NAME_3',\n          size = 0.5)\n\ngdppc <- tm_shape(hunan)+\n  tm_polygons('GDPPC') +\n    tm_layout(legend.height = 0.20, \n            legend.width = 0.25)\n  \n# or gdppc <- qtm(hunan, \"GDPPC\")\n\ntmap_arrange(basemap, gdppc,\n           asp=1,\n           ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-7-1.png){width=1344}\n:::\n:::\n\n\n## **8.5 Computing Contiguity Spatial Weights**\n\nIn this section, we will use [*poly2nb()*](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package to compute contiguity weight matrices for the study area. This function builds a neighbours list based on regions with contiguous boundaries. **Use this if we know that for a variable, sharing common boundary increases spatial interaction.**\n\nBy default, 'queen' argument is set to TRUE: two polygons sharing one shared boundary point will meet contiguity condition. Returns a list of first order neighbours using the Queen criteria.\n\nIf 'queen' argument is set to FALSE: requires more than one shared boundary point. (but may not mean a shared boundary line)\n\n### **8.5.1 Computing (QUEEN) contiguity based neighbours**\n\nThe code chunk below is used to compute Queen contiguity weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n:::\n:::\n\n\nThe summary report above shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours. There are two area units with only one heighbours.\n\n`wm_q` (weights matrix queen) **class: 'nb'**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"nb\"\n```\n:::\n:::\n\n\nA quick peak at `wm_q`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(wm_q,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1]  2  3  4 57 85\n\n[[2]]\n[1]  1 57 58 78 85\n\n[[3]]\n[1]  1  4  5 85\n```\n:::\n:::\n\n\nFor each polygon in our polygon object, *wm_q* lists all neighboring polygons. For example, to see the neighbors for the first polygon in the object, type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  3  4 57 85\n```\n:::\n:::\n\n\nPolygon 1 has 5 neighbors. The numbers represent the polygon IDs as stored in hunan SpatialPolygonsDataFrame class.\n\nWe can retrive the county name of Polygon ID=1 by using the code chunk below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan$County[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Anxiang\"\n```\n:::\n:::\n\n\nPolygon ID=1 is Anxiang county.\n\nTo reveal the county names of the five neighboring polygons, the code chunk will be used:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- wm_q[[1]]\nhunan$County[c(x1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n```\n:::\n:::\n\n\nThe printed output above shows that the GDPPC of the five nearest neighbours based on Queen's method are 20981, 34592, 24473, 21311 and 22879 respectively.\n\nTo display the complete weight matrix, use *str()*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"sym\")= logi TRUE\n```\n:::\n\n```{.r .cell-code}\n#wm_q[1:10]\n#methods(class = class(wm_q))\n```\n:::\n\n\n### **8.5.2 Creating (ROOK) contiguity based neighbours**\n\nThe code chunk below is used to compute Rook contiguity weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n```\n:::\n:::\n\n\nThe summary report above shows that there are 88 area units in Hunan. The most connect area unit has 10 neighbours. There are two area units with only one heighbours.\n\n### 8.5.3 Visualising contiguity weights (find centroid coords first)\n\nA connectivity graph takes a point and displays a line to each neighbouring point.\n\n-   need a point in polygon via polygon centroids (its lat & long) \\<- calculate using the sf package first\n\nTo obtain coordinates in a separate data frame\n\n1.  input vector is the geometry column of us.bound (in `hunan`), an sf object \\<- a polygon\n\n    Using hunan\\$geometry\\[\\[1\\]\\]: The input vector of the FIRST POLYGON looks like POLYGON ((112.0625 29.75523, 112.069 29.74544, 112.0707 29.7415, 112.0716 29.73667, .... , 112.0625 29.75523).\n\n2.  To find the centroid (CG) of one polygon, use the `st_centroid()` function, which is a formula shorthand for a small anonymous function (lambda function). It takes an argument represented by **`.x`**. `st_centroid(.x)[[1]]` extracts the X-coordinate (longitude) of the centroid while `st_centroid(.x)[[2]]` extracts the Y-coords.\n\n    ::: panel-tabset\n    #### X and Y\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    #hunan$geometry[[1]]\n    st_centroid(hunan$geometry[[1]])\n    ```\n    :::\n\n\n    #### X only\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    st_centroid(hunan$geometry[[1]])[[1]]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 112.1531\n    ```\n    :::\n    :::\n\n\n    #### Y only\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    st_centroid(hunan$geometry[[1]])[[2]]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 29.44362\n    ```\n    :::\n    :::\n\n    :::\n\n**`map_dbl(...)`** is a function from the **`purrr`** package that applies a function to each element of a list or vector and returns the results as a double vector. In this case, the function being applied is the expression following **`~`**. Example of how this function is used in a simple way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example list of vectors\nlist_of_vectors <- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))\n\n# Applying a function to calculate the sum of each vector\nmap_dbl(list_of_vectors, ~ sum(.x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n a  b  c \n 6 15 24 \n```\n:::\n:::\n\n\nAfter finding centroid, to access longitude values\n\n-   double bracket notation \\[\\[ \\]\\] and 1\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n    longitude\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1] 112.1531 112.0372 111.8917 111.7031 111.6138 111.0341 113.7065 112.3460\n     [9] 112.8169 113.3534 113.8942 112.4006 112.5542 113.6636 112.9206 113.1883\n    [17] 113.4521 112.4209 113.0152 112.6350 112.7087 112.9095 111.9522 110.2606\n    [25] 110.0921 109.7985 109.5765 109.7211 109.7339 109.1537 110.6442 110.5916\n    [33] 109.5984 111.4783 112.1745 111.2315 110.3149 111.3248 110.5859 110.9593\n    [41] 111.8296 110.1926 110.7334 110.9123 111.4599 112.5268 112.3406 109.5602\n    [49] 109.5071 109.9954 109.4273 109.7587 109.5044 109.9899 109.9664 111.3785\n    [57] 112.4350 112.5558 111.7379 112.1831 111.9743 111.7009 112.2196 112.6472\n    [65] 113.5102 113.1172 113.7089 112.7963 110.9276 113.6420 113.4577 113.8404\n    [73] 113.4758 113.1428 110.3017 113.1957 111.7410 112.1831 111.3390 111.8208\n    [81] 110.0753 112.3965 112.7683 113.1679 111.4495 112.7956 111.5896 111.2393\n    ```\n    :::\n    :::\n\n\nTo access the latitude value\n\n-   double bracket notation \\[\\[ \\]\\] and 2\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n    ```\n    :::\n\n\nWith both longitude and latitude, use cbind() to combine both in the same object,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- cbind(longitude, latitude)\nhead(coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n```\n:::\n:::\n\n\n#### 8.5.3.1 Plotting Queen contiguity based neighbours map\n\nwm\\_ q is weight matrix using queen method (88 rows of list of neighbours)\n\ncoords is an array of x,y coordinates of centroids for each of the 88 counties\n\n\n::: {.cell fig.asp='0.6'}\n\n```{.r .cell-code}\nplot(hunan$geometry, border=\"lightgrey\", main=\"Queen's contiguity\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-23-1.png){width=1344}\n:::\n:::\n\n\n> Use the [plot()](https://www.digitalocean.com/community/tutorials/plot-function-in-r) function\n>\n> 1.  **The shape of the markers:** The plot markers are by default small, empty circles. These are also known as plot characters - denoted by **pch**. Pch values 0 to 25 are valid and give several different symbols on the graph. **Pch** 0 is for a square, 1 is for a circle, 3 is for a triangle, 4 is for a cross and so on.\n>\n> 2.  **Size of the plot markers**: The **cex** parameter can be set to 0.5 if we want the markers to be 50% smaller and 1.5 if wewant them to be 50% larger.\n>\n> 3.  **Color of the plot markers:** These colors can be selected from a list provided by R under the `colors()` function.\n\n#### 8.5.3.2 Plotting Rook contiguity based neighbours map\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nplot(hunan$geometry, border = 'lightgrey', main='Rooks contiguity')\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col =\"blue\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-24-1.png){width=1344}\n:::\n:::\n\n\n#### 8.5.3.3 Plotting both Queen and Rook contiguity based neighbours maps side-by-side\n\n`par(mfrow = c(1, 2))` arranges subsequent plots in a grid with **one** row and **two** columns\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\n\nplot(hunan$geometry, border=\"lightgrey\", main=\"Queen's contiguity\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\", main=\"Queen Contiguity\")\nplot(hunan$geometry, border=\"lightgrey\",main=\"Rook's contiguity\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"blue\", main=\"Rook Contiguity\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-25-1.png){width=1344}\n:::\n:::\n\n\n## 8.6 Computing distance based neighbours\n\n-   In this section, we will derive distance-based weight matrices by using [*dnearneigh()*](https://r-spatial.github.io/spdep/reference/dnearneigh.html) of **spdep** package.\n\n    | dnearneigh(x, d1, d2, row.names = NULL, longlat = NULL, bounds=c(\"GE\", \"LE\"),\n    |  use_kd_tree=TRUE, symtest=FALSE, use_s2=packageVersion(\"s2\") \\> \"1.0.7\", k=200,\n    |  dwithin=TRUE)\n\n-   identifies neighbours using distance band with lower d1= and upper d2= bounds controlled by the `bounds=` argument\n\n-   If unprojected coordinates are used (WSG84 geographic) and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in **km** will be calculated assuming the WGS84 reference ellipsoid.\n\n### **8.6.1 Determine the cut-off distance**\n\nFirstly, we need to determine the upper limit for distance band by using the steps below:\n\n-   Return a **matrix** with the indices of points belonging to the set of the k nearest neighbours of each other by using [*knearneigh()*](https://r-spatial.github.io/spdep/reference/knearneigh.html) of **spdep**. **Class: 'knn'**. Output: NN of poly1 = poly3, NN of poly2 = poly 78 etc...\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    str(knearneigh(coords,\n               k=1))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    List of 5\n     $ nn       : int [1:88, 1] 3 78 1 5 4 69 67 46 84 70 ...\n     $ np       : int 88\n     $ k        : num 1\n     $ dimension: int 2\n     $ x        : num [1:88, 1:2] 112 112 112 112 112 ...\n      ..- attr(*, \"dimnames\")=List of 2\n      .. ..$ : NULL\n      .. ..$ : chr [1:2] \"longitude\" \"latitude\"\n     - attr(*, \"class\")= chr \"knn\"\n     - attr(*, \"call\")= language knearneigh(x = coords, k = 1)\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    #knearneigh(coords,k=1)['nn']  #<< shows matrix\n    ```\n    :::\n\n\n-   Convert the matrix knn object returned by *knearneigh()* into a neighbours **list** with a list of integer vectors containing neighbour region number ids by using [*knn2nb()*](https://r-spatial.github.io/spdep/reference/knn2nb.html). **Class: nb**\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    knn2nb(knearneigh(coords))[1:5]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [[1]]\n    [1] 3\n    \n    [[2]]\n    [1] 78\n    \n    [[3]]\n    [1] 1\n    \n    [[4]]\n    [1] 5\n    \n    [[5]]\n    [1] 4\n    ```\n    :::\n    :::\n\n\n-   Return a list of the **length** (the distance to one's nearest neighbour) of neighbour relationship edges by using [*nbdists()*](https://r-spatial.github.io/spdep/reference/nbdists.html) of **spdep**. The function returns in the units of the coordinates if the coordinates are projected, in km if in WSG84. **Class: 'nbdist'**\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    nbdists(knn2nb(knearneigh(coords, k=1)),\n            coords,\n            longlat = TRUE) [1:5]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [[1]]\n    [1] 25.53398\n    \n    [[2]]\n    [1] 43.03114\n    \n    [[3]]\n    [1] 25.53398\n    \n    [[4]]\n    [1] 29.2848\n    \n    [[5]]\n    [1] 29.2848\n    ```\n    :::\n    :::\n\n\n-   Remove the list structure of the returned object by using [**unlist()**](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/unlist). **Class of k1dists: numeric.**\n\n    Output: 25.53398 43.03114 25.53398 29.28480 29.28480 45.98097 58.52704 28.95985 34.45062 37.99885 44.49442 33.48816 35.98123\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    k1 <- knn2nb(knearneigh(coords, k=1))\n    k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\n    summary(k1dists)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n       Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n      24.79   32.57   38.01   39.07   44.52   61.79 \n    ```\n    :::\n    :::\n\n\n**The summary report shows that the largest first nearest neighbour distance is 61.79. So using this as the upper threshold (62km) will help to ensure that all units (polygons) will have at least one neighbour**.\n\n### 8.6.2 Computing [fixed]{.underline} distance weight matrix\n\n(Earlier, we had used `poly2nb(hunan, queen=TRUE/FALSE)` to define neighbours using Queen or Rook method, resulting in `wm_q` and `wm_r.`)\n\n(We also have `k1` of 'nb' class where each polygon has 1 nb. Additionally, we used summary(unlist(nbdists())) to calculate the distance between furthest neighbours.)\n\nNow, to define neighbours using a **distance threshold**, we use the `dnearneigh()` ,\n\n-   *longlat argument: TRUE if point coordinates are **geographical** longitude-latitude decimal degrees (WSG84)*\n-   some polygons have more than 1 nb, but all polygons have at least 1 nb here due to distance threshold.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_d62 <- dnearneigh(coords, 0, 62, longlat=TRUE )\nwm_d62\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n```\n:::\n:::\n\n\nAverage number of links is calculated by dividing the total number of links by the number of regions. On average, each region has approximately 3.68 neighboring regions. **Class of `wm_d62`: 'nb'**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(wm_d62)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"nb\"\n```\n:::\n:::\n\n\nNext, we will use *str()* to display the content of wm_d62 weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(wm_d62)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 88\n $ : int [1:5] 3 4 5 57 64\n $ : int [1:4] 57 58 78 85\n $ : int [1:4] 1 4 5 57\n $ : int [1:3] 1 3 5\n $ : int [1:4] 1 3 4 85\n $ : int 69\n $ : int [1:2] 67 84\n $ : int [1:4] 9 46 47 78\n $ : int [1:4] 8 46 68 84\n $ : int [1:4] 16 22 70 72\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:2] 11 17\n $ : int 13\n $ : int [1:4] 10 17 22 83\n $ : int [1:3] 11 14 16\n $ : int [1:3] 20 22 63\n $ : int [1:5] 20 21 73 74 82\n $ : int [1:5] 18 19 21 22 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:4] 10 16 18 20\n $ : int [1:3] 41 77 82\n $ : int [1:4] 25 28 31 54\n $ : int [1:4] 24 28 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:2] 26 29\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:2] 27 37\n $ : int 33\n $ : int [1:2] 24 36\n $ : int 50\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:5] 31 34 45 56 80\n $ : int [1:2] 29 42\n $ : int [1:3] 44 77 79\n $ : int [1:4] 40 42 43 81\n $ : int [1:3] 39 45 79\n $ : int [1:5] 23 35 45 79 82\n $ : int [1:5] 26 37 39 43 81\n $ : int [1:3] 39 42 44\n $ : int [1:2] 38 43\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:5] 8 9 35 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:4] 48 49 50 52\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:2] 48 55\n $ : int [1:5] 24 28 49 50 52\n $ : int [1:4] 48 50 53 75\n $ : int 36\n $ : int [1:5] 1 2 3 58 64\n $ : int [1:5] 2 57 64 66 68\n $ : int [1:3] 60 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:5] 12 60 62 63 87\n $ : int [1:4] 61 63 77 87\n $ : int [1:5] 12 18 61 62 83\n $ : int [1:4] 1 57 58 76\n $ : int 76\n $ : int [1:5] 58 67 68 76 84\n $ : int [1:2] 7 66\n $ : int [1:4] 9 58 66 84\n $ : int [1:2] 6 75\n $ : int [1:3] 10 72 73\n $ : int [1:2] 73 74\n $ : int [1:3] 10 11 70\n $ : int [1:4] 19 70 71 74\n $ : int [1:5] 19 21 71 73 86\n $ : int [1:2] 55 69\n $ : int [1:3] 64 65 66\n $ : int [1:3] 23 38 62\n $ : int [1:2] 2 8\n $ : int [1:4] 38 40 41 45\n $ : int [1:5] 34 35 36 45 47\n $ : int [1:5] 25 26 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:4] 12 13 16 63\n $ : int [1:4] 7 9 66 68\n $ : int [1:2] 2 5\n $ : int [1:4] 21 46 47 74\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 62, longlat = TRUE)\n - attr(*, \"dnn\")= num [1:2] 0 62\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE\n```\n:::\n:::\n\n\nAnother way to display the structure of the weight matrix is to combine [*table()*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/table) and [*card()*](https://r-spatial.github.io/spdep/reference/card.html) of spdep.\n\nThe column headers \"1\" means the count of counties that have 1 neighbor within the specified distance of 62km, \"2\" means the count of counties that have 2 neighbors, and so on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(hunan$County, card(wm_d62))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               \n                1 2 3 4 5 6\n  Anhua         1 0 0 0 0 0\n  Anren         0 0 0 1 0 0\n  Anxiang       0 0 0 0 1 0\n  Baojing       0 0 0 0 1 0\n  Chaling       0 0 1 0 0 0\n  Changning     0 0 1 0 0 0\n  Changsha      0 0 0 1 0 0\n  Chengbu       0 1 0 0 0 0\n  Chenxi        0 0 0 1 0 0\n  Cili          0 1 0 0 0 0\n  Dao           0 0 0 1 0 0\n  Dongan        0 0 1 0 0 0\n  Dongkou       0 0 0 1 0 0\n  Fenghuang     0 0 0 1 0 0\n  Guidong       0 0 1 0 0 0\n  Guiyang       0 0 0 1 0 0\n  Guzhang       0 0 0 0 0 1\n  Hanshou       0 0 0 1 0 0\n  Hengdong      0 0 0 0 1 0\n  Hengnan       0 0 0 0 1 0\n  Hengshan      0 0 0 0 0 1\n  Hengyang      0 0 0 0 0 1\n  Hongjiang     0 0 0 0 1 0\n  Huarong       0 0 0 1 0 0\n  Huayuan       0 0 0 1 0 0\n  Huitong       0 0 0 1 0 0\n  Jiahe         0 0 0 0 1 0\n  Jianghua      0 0 1 0 0 0\n  Jiangyong     0 1 0 0 0 0\n  Jingzhou      0 1 0 0 0 0\n  Jinshi        0 0 0 1 0 0\n  Jishou        0 0 0 0 0 1\n  Lanshan       0 0 0 1 0 0\n  Leiyang       0 0 0 1 0 0\n  Lengshuijiang 0 0 1 0 0 0\n  Li            0 0 1 0 0 0\n  Lianyuan      0 0 0 0 1 0\n  Liling        0 1 0 0 0 0\n  Linli         0 0 0 1 0 0\n  Linwu         0 0 0 1 0 0\n  Linxiang      1 0 0 0 0 0\n  Liuyang       0 1 0 0 0 0\n  Longhui       0 0 1 0 0 0\n  Longshan      0 1 0 0 0 0\n  Luxi          0 0 0 0 1 0\n  Mayang        0 0 0 0 0 1\n  Miluo         0 0 0 0 1 0\n  Nan           0 0 0 0 1 0\n  Ningxiang     0 0 0 1 0 0\n  Ningyuan      0 0 0 0 1 0\n  Pingjiang     0 1 0 0 0 0\n  Qidong        0 0 1 0 0 0\n  Qiyang        0 0 1 0 0 0\n  Rucheng       0 1 0 0 0 0\n  Sangzhi       0 1 0 0 0 0\n  Shaodong      0 0 0 0 1 0\n  Shaoshan      0 0 0 0 1 0\n  Shaoyang      0 0 0 1 0 0\n  Shimen        1 0 0 0 0 0\n  Shuangfeng    0 0 0 0 0 1\n  Shuangpai     0 0 0 1 0 0\n  Suining       0 0 0 0 1 0\n  Taojiang      0 1 0 0 0 0\n  Taoyuan       0 1 0 0 0 0\n  Tongdao       0 1 0 0 0 0\n  Wangcheng     0 0 0 1 0 0\n  Wugang        0 0 1 0 0 0\n  Xiangtan      0 0 0 1 0 0\n  Xiangxiang    0 0 0 0 1 0\n  Xiangyin      0 0 0 1 0 0\n  Xinhua        0 0 0 0 1 0\n  Xinhuang      1 0 0 0 0 0\n  Xinning       0 1 0 0 0 0\n  Xinshao       0 0 0 0 0 1\n  Xintian       0 0 0 0 1 0\n  Xupu          0 1 0 0 0 0\n  Yanling       0 0 1 0 0 0\n  Yizhang       1 0 0 0 0 0\n  Yongshun      0 0 0 1 0 0\n  Yongxing      0 0 0 1 0 0\n  You           0 0 0 1 0 0\n  Yuanjiang     0 0 0 0 1 0\n  Yuanling      1 0 0 0 0 0\n  Yueyang       0 0 1 0 0 0\n  Zhijiang      0 0 0 0 1 0\n  Zhongfang     0 0 0 1 0 0\n  Zhuzhou       0 0 0 0 1 0\n  Zixing        0 0 1 0 0 0\n```\n:::\n:::\n\n\nTO find the number of connected components (aka see if there are any spatial units / regions without a neighbour)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_comp <- n.comp.nb(wm_d62)\nn_comp$nc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nIn this connected component, there are 88 elements (spatial units)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(n_comp$comp.id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n 1 \n88 \n```\n:::\n:::\n\n\n#### 8.6.2.1 Plotting fixed distance weight matrix\n\nNext, we will plot the distance weight matrix by using the code chunk below.\n\n-   wm_d62 is the fixed distance weight matrix,\n\n-   coords refers to long, lat coordinates for CG of each polygon\n\n-   k1 is the list of integer ID of the polygon which is the nearest neighbour to me. The topmost layer of the plot colours the nearest neighbour edge to red colour.\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_d62, coords, add=TRUE)\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08) \n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-36-1.png){width=1344}\n:::\n:::\n\n\nThe red lines shows the links of 1st nearest neighbours and the black lines show the lines of neighbours within the cut-off distance of 62km.\n\nTo plot red and black side by side,\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\npar(mfrow = c(1, 2))\nplot(hunan$geometry, border=\"lightgrey\", main = 'Neighbours within 62 km')\nplot(wm_d62, coords, add=TRUE)\nplot(hunan$geometry, border=\"lightgrey\", main = 'Nearest Neighbour')\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08) \n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-37-1.png){width=1344}\n:::\n:::\n\n\n### **8.6.3 Computing adaptive distance weight matrix**\n\n**Use this method if the dataset is highly skewed to fix the \\# of nbs.**\n\nEarlier, we used `k1 <- knn2nb(knearneigh(coords, k=1))` and `wm_d62 <- dnearneigh(coords, 0, 62, longlat=TRUE )` to plot maps of nearest nb and nbs within 62km range.\n\nOne of the characteristics of fixed distance weight matrix is that more densely settled areas (usually the urban areas) tend to have more neighbours and the less densely settled areas (usually the rural counties) tend to have lesser neighbours. Having many neighbours smoothes the neighbour relationship across more neighbours.\n\nIt is possible to control the numbers of neighbours directly using k-nearest neighbours, either accepting asymmetric neighbours or imposing symmetry as shown in the code chunk below. **class of `knn6`: 'nb'**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknn6 <- knn2nb(knearneigh(coords, k=6))\nknn6\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 528 \nPercentage nonzero weights: 6.818182 \nAverage number of links: 6 \nNon-symmetric neighbours list\n```\n:::\n:::\n\n\nSimilarly, we can display the content of the matrix by using *str()*. Note that each spatial units has exactly 6 neighbours.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(knn6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 88\n $ : int [1:6] 2 3 4 5 57 64\n $ : int [1:6] 1 3 57 58 78 85\n $ : int [1:6] 1 2 4 5 57 85\n $ : int [1:6] 1 3 5 6 69 85\n $ : int [1:6] 1 3 4 6 69 85\n $ : int [1:6] 3 4 5 69 75 85\n $ : int [1:6] 9 66 67 71 74 84\n $ : int [1:6] 9 46 47 78 80 86\n $ : int [1:6] 8 46 66 68 84 86\n $ : int [1:6] 16 19 22 70 72 73\n $ : int [1:6] 10 14 16 17 70 72\n $ : int [1:6] 13 15 60 61 63 83\n $ : int [1:6] 12 15 60 61 63 83\n $ : int [1:6] 11 15 16 17 72 83\n $ : int [1:6] 12 13 14 17 60 83\n $ : int [1:6] 10 11 17 22 72 83\n $ : int [1:6] 10 11 14 16 72 83\n $ : int [1:6] 20 22 23 63 77 83\n $ : int [1:6] 10 20 21 73 74 82\n $ : int [1:6] 18 19 21 22 23 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:6] 10 16 18 19 20 83\n $ : int [1:6] 18 20 41 77 79 82\n $ : int [1:6] 25 28 31 52 54 81\n $ : int [1:6] 24 28 31 33 54 81\n $ : int [1:6] 25 27 29 33 42 81\n $ : int [1:6] 26 29 30 37 42 81\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:6] 26 27 37 42 43 81\n $ : int [1:6] 26 27 28 33 49 81\n $ : int [1:6] 24 25 36 39 40 54\n $ : int [1:6] 24 31 50 54 55 56\n $ : int [1:6] 25 26 28 30 49 81\n $ : int [1:6] 36 40 41 45 56 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:6] 26 27 29 42 43 44\n $ : int [1:6] 23 43 44 62 77 79\n $ : int [1:6] 25 40 42 43 44 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:6] 26 27 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:6] 37 38 39 42 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:6] 8 9 35 47 78 86\n $ : int [1:6] 8 21 35 46 80 86\n $ : int [1:6] 49 50 51 52 53 55\n $ : int [1:6] 28 33 48 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:6] 28 48 49 50 52 54\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:6] 48 50 51 52 55 75\n $ : int [1:6] 24 28 49 50 51 52\n $ : int [1:6] 32 48 50 52 53 75\n $ : int [1:6] 32 34 36 78 80 85\n $ : int [1:6] 1 2 3 58 64 68\n $ : int [1:6] 2 57 64 66 68 78\n $ : int [1:6] 12 13 60 61 87 88\n $ : int [1:6] 12 13 59 61 63 87\n $ : int [1:6] 12 13 60 62 63 87\n $ : int [1:6] 12 38 61 63 77 87\n $ : int [1:6] 12 18 60 61 62 83\n $ : int [1:6] 1 3 57 58 68 76\n $ : int [1:6] 58 64 66 67 68 76\n $ : int [1:6] 9 58 67 68 76 84\n $ : int [1:6] 7 65 66 68 76 84\n $ : int [1:6] 9 57 58 66 78 84\n $ : int [1:6] 4 5 6 32 75 85\n $ : int [1:6] 10 16 19 22 72 73\n $ : int [1:6] 7 19 73 74 84 86\n $ : int [1:6] 10 11 14 16 17 70\n $ : int [1:6] 10 19 21 70 71 74\n $ : int [1:6] 19 21 71 73 84 86\n $ : int [1:6] 6 32 50 53 55 69\n $ : int [1:6] 58 64 65 66 67 68\n $ : int [1:6] 18 23 38 61 62 63\n $ : int [1:6] 2 8 9 46 58 68\n $ : int [1:6] 38 40 41 43 44 45\n $ : int [1:6] 34 35 36 41 45 47\n $ : int [1:6] 25 26 28 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:6] 12 13 15 16 22 63\n $ : int [1:6] 7 9 66 68 71 74\n $ : int [1:6] 2 3 4 5 56 69\n $ : int [1:6] 8 9 21 46 47 74\n $ : int [1:6] 59 60 61 62 63 88\n $ : int [1:6] 59 60 61 62 63 87\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language knearneigh(x = coords, k = 6)\n - attr(*, \"sym\")= logi FALSE\n - attr(*, \"type\")= chr \"knn\"\n - attr(*, \"knn-k\")= num 6\n - attr(*, \"class\")= chr \"nb\"\n```\n:::\n:::\n\n\n#### 8.6.3.1 Plotting distance based neighbours\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nplot(st_geometry(hunan), border = 'lightgray')\nplot(knn6, coords, pch=18, cex=0.6, add= TRUE, col='red')\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-40-1.png){width=1344}\n:::\n:::\n\n\n## **8.7 Weights based on Inverse Distance Method**\n\nIn this section, we will learn how to derive a spatial weight matrix based on Inversed Distance method. **This will assign greater weightage to closer polygons, use this if we know that closer proximity will result in more spatial interaction.**\n\nEarlier, we applied nbdists() `nbdists(knn2nb(knearneigh(coords, k=1)), coords, longlat = TRUE)` to compute the distance of one's nearest neighbour.\n\nFirst, we will compute the distances between areas (defined using Queen contiguity method) by using [*nbdists()*](https://r-spatial.github.io/spdep/reference/nbdists.html) of **spdep**. **Class of dist: nbdist**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist <- nbdists(wm_q, coords, longlat=TRUE)\nhead(dist,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 65.12941 25.53398 54.91802 35.61352 87.32760\n\n[[2]]\n[1] 65.12941 56.67944 51.92312 43.03114 58.16151\n\n[[3]]\n[1] 25.53398 35.43536 27.05778 71.64530\n```\n:::\n:::\n\n\nNow compute the inverse distances for all polygons to their neighbours. **Class of ids: matrix of list.** `ids` is also glist (general weights for each nb).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nids <- lapply(dist, function(x) 1/(x))\nhead(ids,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n[[2]]\n[1] 0.01535405 0.01764308 0.01925924 0.02323898 0.01719350\n\n[[3]]\n[1] 0.03916350 0.02822040 0.03695795 0.01395765\n```\n:::\n:::\n\n\n### **8.7.1 Row-standardised weights matrix**\n\n`nb2listw(neighbours, glist=NULL, style=\"W\", zero.policy=NULL)`\n\nArguments\n\n| `neighbours`  | an object of class `nb`                                                                                                                                                     |\n|----------------------|--------------------------------------------------|\n| `glist`       | list of general weights corresponding to neighbours                                                                                                                         |\n| `style`       | `style` can take values \"W\", \"B\", \"C\", \"U\", \"minmax\" and \"S\"                                                                                                                |\n| `zero.policy` | default NULL, use global option value; if FALSE stop with error for any empty neighbour sets, if TRUE permit the weights list to be formed with zero-length weights vectors |\n\n**Details**\n\nStarting from a binary neighbours list, in which regions are either listed as neighbours or are absent (thus not in the set of neighbours for some definition), the function adds a weights list with values given by the coding scheme style chosen.\n\nWeights to each neighboring polygon\n\n-   each neighboring polygon will be assigned equal weight (style=\"W\") \\<- row standardised. This is accomplished by assigning the fraction 1/(#ofneighbors) to each neighboring county then summing the weighted income values\n\n-   drawback of this method is that polygon along the edge will base their lagged values on fewer polygons, thus over estimating the true nature of spatial autocorrelation in the data. Next time can consider other more robust options are available, notably style=\"B\" \\<- basic binary coding\n\n-   The zero.policy=TRUE option allows for lists of non-neighbors. This should be used with caution since the user may not be aware of missing neighbors in their dataset however, a zero.policy of FALSE would return an error. **Class of rsmq_q = 'listw' and 'nb'**\n\n::: panel-tabset\n#### style = 'W'\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# wm_q is a matrix containing nb indexes\nrswm_q <- nb2listw(wm_q, style = 'W', zero.policy = TRUE)\nrswm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n:::\n:::\n\n\n#### style = 'B'\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb2listw(wm_q, style = 'B', zero.policy = TRUE)$weights[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 1 1 1 1\n```\n:::\n:::\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(rswm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"listw\" \"nb\"   \n```\n:::\n:::\n\n\nTo see the weight of the first polygon's 5 neighbours type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q$weights[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 0.2 0.2 0.2 0.2 0.2\n```\n:::\n:::\n\n\nThe 5 neighbours are\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q$neighbours[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1]  2  3  4 57 85\n```\n:::\n:::\n\n\nExplanation of above: Each neighbor is assigned a 0.125 of the total weight. This means that when R computes the average neighboring income values, each **neighbor's income will be multiplied by 0.125 before being tallied.**\n\nUsing the same queen's method, we can also derive a (row standardised ?) inverse-distance weight matrix by using the code chunk below. Recall `ids` contains inverse-distances to neighbours, also our glist (general weights of neighbours) , originally from queens `wm_q` which is a neighbour structure. We will now use `nb2listw()` and `wm_q` and `ids` to create a spatial weights matrix. **Class of rswm_ids is 'listw' and 'nb'.** It contains 3 lists, 'style' of class character ,'neighbours' of class nb, 'weights' of class nb\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_ids <- nb2listw(wm_q, glist=ids, style ='W', zero.policy=TRUE)\nrswm_ids\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 40.39879 361.0957\n```\n:::\n:::\n\n\nTo see the weights of the 1st polygon; it is actually the similar as `ids`, but not identical.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_ids$weights[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 0.1367760 0.3488740 0.1622080 0.2501337 0.1020083\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(unlist(rswm_ids$weights))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n0.05894 0.13342 0.17603 0.19643 0.23961 1.00000 \n```\n:::\n:::\n\n\nFinally, a comparison of the weights for polygon 1 across three spatial weights methods:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- unlist(rswm_q$weights[1])\nb <- unlist(nb2listw(wm_q, style = 'B', zero.policy = TRUE)$weights[1])\nc <- unlist(rswm_ids$weights[1])\n\nweights_comparison <- as.data.frame(cbind(a,b,c))\ncolnames(weights_comparison) <- c(\"row standardised\", \"binary\", 'row standardised inverse distance')\nweights_comparison\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  row standardised binary row standardised inverse distance\n1              0.2      1                         0.1367760\n2              0.2      1                         0.3488740\n3              0.2      1                         0.1622080\n4              0.2      1                         0.2501337\n5              0.2      1                         0.1020083\n```\n:::\n:::\n\n\n## **8.8 Application of Spatial Weight Matrix**\n\nIn this section, you will learn how to create four different spatial lagged variables, they are:\n\n-   spatial lag with row-standardized weights,\n\n-   spatial lag as a sum of neighbouring values,\n\n-   spatial window average, and\n\n-   spatial window sum.\n\n### 8.8.1 Spatial lag with row-standardized weights\n\n-   compute the average neighbour GDPCC values for each polygon\n\n-   commonly called spatially lagged values\n\n-   does not include itself\n\n-   Recalled in the previous section, we retrieved the GDPPC of these five countries (neighbours of poly1 using queen method) by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- wm_q[[1]]\nhunan$GDPPC[c(x1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20981 34592 24473 21311 22879\n```\n:::\n:::\n\n\n-   Now we compute the row-standardised lag variable using `lag.listw()` and `rsqm_q` (neighbour structure).\n\n-   In the code below, use spatial weight matrix (equal weightage of 0.2 for poly1 etc.. ) by 0.2 \\* 20981 + 0.2 \\* 34592 + 0.2 \\* 24473 + 0.2 \\* 21311 + 0.2 \\* 22879 = 24847.20 for poly1 \"Anxiang\"\n\n-   22724.80 is the average GDPPC for poly2 based on equal weightage (0.2) of all its five neighbours . 24143.25 for poly3 based on equal weightage (0.25) based on four neighbours.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)\nGDPPC.lag\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n```\n:::\n:::\n\n\nWe can append the spatially lag GDPPC values onto hunan sf data frame by using the code chunk below.\n\nFirst, create `lag.list` that contains two **individual** lists, namely NAME_3 column in `hunan` and the lag variable. Next, transform both lists into a dataframe. Rename the column headers. Perform a left join with hunan and lag.res will automatically use `NAME_3` column as the join column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))\nstr(lag.list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ : chr [1:88] \"Anxiang\" \"Hanshou\" \"Jinshi\" \"Li\" ...\n $ : num [1:88] 24847 22725 24143 27738 27270 ...\n```\n:::\n\n```{.r .cell-code}\nlag.res <- as.data.frame(lag.list)\ncolnames(lag.res) <- c(\"NAME_3\", \"lag GDPPC\")\nhunan <- left_join(hunan,lag.res)\n\nhead(as_tibble(hunan),3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 Ã— 8\n  NAME_2   ID_3 NAME_3  ENGTYPE_3   County  GDPPC `lag GDPPC`\n  <chr>   <int> <chr>   <chr>       <chr>   <dbl>       <dbl>\n1 Changde 21098 Anxiang County      Anxiang 23667      24847.\n2 Changde 21100 Hanshou County      Hanshou 20981      22725.\n3 Changde 21101 Jinshi  County City Jinshi  34592      24143.\n# â„¹ 1 more variable: geometry <POLYGON [Â°]>\n```\n:::\n\n```{.r .cell-code}\n# head(hunan,3) %>%  kable()\n```\n:::\n\n\nThe following table shows the average neighboring income values (stored in the Inc.lag object) for each county.\n\nNext, we will plot both the GDPPC and spatial lag GDPPC for comparison using the code chunk below.\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\ngdppc <- qtm(hunan, 'GDPPC') +\n    tm_layout(main.title='No lag variable',\n              legend.height = 0.2,\n              legend.width=0.2)\nlag_gdppc <- qtm(hunan, 'lag GDPPC') +\n  tm_layout(main.title='With lag variable (Row-stand)',\n            legend.height = 0.2,\n            legend.width=0.4)\n\ntmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-55-1.png){width=1344}\n:::\n:::\n\n\n::: callout-note\nThe chart on the left plots the original GDPPC values of respective spatial units. The chart on the right plots the average GDPPC values of all spatial units that shares a boundary (Queen) for a particular spatial unit. Does not include diagonal (own's) GDPPC value.\n:::\n\nCompute lag variable using rswm_ids (inverse-distance method)\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nlag.list.2 <- list(hunan$NAME_3, lag.listw(rswm_ids, hunan$GDPPC))\nstr(lag.list.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ : chr [1:88] \"Anxiang\" \"Hanshou\" \"Jinshi\" \"Li\" ...\n $ : num [1:88] 26572 22568 24356 28108 28265 ...\n```\n:::\n\n```{.r .cell-code}\nlag.res.2 <- as.data.frame(lag.list.2)\ncolnames(lag.res.2) <- c(\"NAME_3\", \"lag GDPPC ID\")\nhunan <- left_join(hunan,lag.res.2)\n\nhead(as_tibble(hunan),3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 Ã— 9\n  NAME_2   ID_3 NAME_3  ENGTYPE_3   County  GDPPC `lag GDPPC` `lag GDPPC ID`\n  <chr>   <int> <chr>   <chr>       <chr>   <dbl>       <dbl>          <dbl>\n1 Changde 21098 Anxiang County      Anxiang 23667      24847.         26572.\n2 Changde 21100 Hanshou County      Hanshou 20981      22725.         22568.\n3 Changde 21101 Jinshi  County City Jinshi  34592      24143.         24356.\n# â„¹ 1 more variable: geometry <POLYGON [Â°]>\n```\n:::\n\n```{.r .cell-code}\nlag_gdppc_id <- qtm(hunan, 'lag GDPPC ID') +\n  tm_layout(main.title='With lag variable (Inv_dist)',\n            legend.height = 0.2,\n            legend.width=0.4)\n\ntmap_arrange(lag_gdppc, lag_gdppc_id, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-56-1.png){width=1344}\n:::\n:::\n\n\n::: callout-note\n**Lag variable using Queen's contiguity (Row standardised weight matrix)**\n\nThe lag variable represents the spatial AVERAGE of GDPPC for neighbouring areas based on Queen contiguity.\n\n**Lag variable using Inverse-Distance Weight matrix**\n\nThe lag variable is calculated as a WEIGHTED AVERAGE of GDPPC. Further neighbours are penalised (assign lesser weights) when we use inverse-distance.\n:::\n\n### **8.8.2 Spatial lag as a sum of neighboring values**\n\n**Part 1: Obtain binary weights matrix called \\'b_weights\\' (glist):**\n\nwm_q (aka neighbour list) is a \\'nb\\' class containing neighbour IDs for each polygon. E.g. Neighbours list of the first three polygons:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1]  2  3  4 57 85\n\n[[2]]\n[1]  1 57 58 78 85\n\n[[3]]\n[1]  1  4  5 85\n```\n:::\n:::\n\n\nTo create a binary list, we will now apply lambda function of 0\\*neighbour ID + 1 ; so that if there is a neighbour, the value is 1. Class of b_weights is a matrix with lists of 1 .\n\nSimilar to `ids` earlier, b_weights is the glist (general weights corresponding to neighbours). We need the neighbour structure `wm_q` and `glist` to convert to spatial weights matrix using `nb2listw()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights <- lapply(wm_q, function(x) 0*x+1)\nclass(b_weights)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nb_weights[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 1 1 1 1\n\n[[2]]\n[1] 1 1 1 1 1\n\n[[3]]\n[1] 1 1 1 1\n```\n:::\n:::\n\n\n**Part 2: Create the spatial weights matrix using nb2listw() , `wm_q` (neighbour structure) and `b_weights`** (glist)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights2 <- nb2listw(wm_q, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n```\n:::\n:::\n\n\nSneakpeak at b_weights2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights2$weights[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 1 1 1 1\n\n[[2]]\n[1] 1 1 1 1 1\n\n[[3]]\n[1] 1 1 1 1\n```\n:::\n:::\n\n\nWith the proper weights assigned, we can use lag.listw to compute a lag variable from our weight and GDPPC. Since the weights are all '1's, we will be summing all our neighbours' GDPPC.\n\nlag_sum contains two lists, namely `NAME_3` and `lag_sum GDPPC`. Combine both lists into a df. Rename the df column headers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nstr(lag_sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ : chr [1:88] \"Anxiang\" \"Hanshou\" \"Jinshi\" \"Li\" ...\n $ : num [1:88] 124236 113624 96573 110950 109081 ...\n```\n:::\n\n```{.r .cell-code}\nlag.res <- as.data.frame(lag_sum)\ncolnames(lag.res) <- c('NAME_3', 'lag_sum GDPPC')\n```\n:::\n\n\nNext, append `lag.res` to `hunan` sf dataframe\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, lag.res)\n```\n:::\n\n\nPlot both the *GDPPC* and *Spatial Lag Sum GDPPC* for comparison using the code chunk below.\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\ngdppc <- qtm(hunan, 'GDPPC') +\n    tm_layout(main.title='No lag variable',\n              legend.height = 0.2,\n              legend.width=0.2)\n\nlag_sum_gdppc <- qtm(hunan, 'lag_sum GDPPC') +\n  tm_layout(main.title = 'spatial lag as lag sum of nb values',\n            legend.height = 0.2,\n            legend.width=0.2)\n\ntmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-63-1.png){width=1344}\n:::\n:::\n\n\n::: callout-note\nThe lag variable created by summing up neighbours' GDPPC look more alike the lag variable created using inverse-distance weights matrix.\n:::\n\n### 8.8.3 Spatial window average\n\n-   must use row-standardized weights\n\n-   similar to 8.8.1 but only difference is that it includes the diagonal element;\n\n-   To include diagonal in R, we need to go back to the neighbors structure `wm_q` and add the diagonal element before assigning weights.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# weight matrix queen self\nwm_qs <- include.self(wm_q)\nwm_qs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n```\n:::\n\n```{.r .cell-code}\nwm_qs[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1]  1  2  3  4 57 85\n\n[[2]]\n[1]  1  2 57 58 78 85\n\n[[3]]\n[1]  1  3  4  5 85\n```\n:::\n:::\n\n\nWe can see that polygon 1 has its diagonal (1) inside and polygon 2 has its diagonal (2) inside.We can see that polygon 1 has its diagonal (1) inside and polygon 2 has its diagonal (2) inside.\n\nAs expected, the Number of nonzero links, Percentage nonzero weights and Average number of links are 536, 6.921488 and 6.090909 respectively as compared to wm_q of 448, 5.785124 and 5.090909.\n\nNow, proceed to create the spatial weights matrix that includes self:\n\nDefault style is 'W' - row standardised.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_qs <- nb2listw(wm_qs, style ='W', zero.policy = TRUE)\nwm_qs$weights[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 0.1666667 0.1666667 0.1666667 0.1666667 0.1666667 0.1666667\n\n[[2]]\n[1] 0.1666667 0.1666667 0.1666667 0.1666667 0.1666667 0.1666667\n\n[[3]]\n[1] 0.2 0.2 0.2 0.2 0.2\n```\n:::\n:::\n\n\nNow, create lag variable using spatial weights matrix `wm_qs` and `hunan$GDPCC` variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag_w_ave_gdppc <- lag.listw(wm_qs,\n                             hunan$GDPPC)\nlag_w_ave_gdppc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 24650.50 22434.17 26233.00 27084.60 26927.00 22230.17 47621.20 37160.12\n [9] 49224.71 29886.89 26627.50 22690.17 25366.40 25825.75 30329.00 32682.83\n[17] 25948.62 23987.67 25463.14 21904.38 23127.50 25949.83 20018.75 19524.17\n[25] 18955.00 17800.40 15883.00 18831.33 14832.50 17965.00 17159.89 16199.44\n[33] 18764.50 26878.75 23188.86 20788.14 12365.20 15985.00 13764.83 11907.43\n[41] 17128.14 14593.62 11644.29 12706.00 21712.29 43548.25 35049.00 16226.83\n[49] 19294.40 18156.00 19954.75 18145.17 12132.75 18419.29 14050.83 23619.75\n[57] 24552.71 24733.67 16762.60 20932.60 19467.75 18334.00 22541.00 26028.00\n[65] 29128.50 46569.00 47576.60 36545.50 20838.50 22531.00 42115.50 27619.00\n[73] 27611.33 44523.29 18127.43 28746.38 20734.50 33880.62 14716.38 28516.22\n[81] 18086.14 21244.50 29568.80 48119.71 22310.75 43151.60 17133.40 17009.33\n```\n:::\n:::\n\n\nAppend `lag_w_ave_gdppc` to the `hunan` dataframe by using the series of steps below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag.list.wm_qs <- list(hunan$NAME_3, lag.listw(wm_qs, hunan$GDPPC))\nstr(lag.list.wm_qs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ : chr [1:88] \"Anxiang\" \"Hanshou\" \"Jinshi\" \"Li\" ...\n $ : num [1:88] 24651 22434 26233 27085 26927 ...\n```\n:::\n\n```{.r .cell-code}\nlag_wm_qs.res <- as.data.frame(lag.list.wm_qs)\ncolnames(lag_wm_qs.res) <- c('NAME_3', 'lag_window_avg GDPPC')\n\nhunan <- left_join(hunan, lag_wm_qs.res)\n\nhunan %>% \n  select('County', 'lag GDPPC', 'lag_window_avg GDPPC') %>% \n  head() %>% \n  kable()\n```\n\n::: {.cell-output-display}\n|County  | lag GDPPC| lag_window_avg GDPPC|geometry                       |\n|:-------|---------:|--------------------:|:------------------------------|\n|Anxiang |  24847.20|             24650.50|POLYGON ((112.0625 29.75523... |\n|Hanshou |  22724.80|             22434.17|POLYGON ((112.2288 29.11684... |\n|Jinshi  |  24143.25|             26233.00|POLYGON ((111.8927 29.6013,... |\n|Li      |  27737.50|             27084.60|POLYGON ((111.3731 29.94649... |\n|Linli   |  27270.25|             26927.00|POLYGON ((111.6324 29.76288... |\n|Shimen  |  21248.80|             22230.17|POLYGON ((110.8825 30.11675... |\n:::\n\n```{.r .cell-code}\n#as_tibble(hunan)  #<< will isolate the geometry part\n```\n:::\n\n\nUse dtm() to plot 'lag GDPPC' and 'lag_window_avg GDPPC' side-by-side\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nW_avg_gdppc <- qtm(hunan, 'lag_window_avg GDPPC') +\n  tm_layout(main.title='With lag_sum variable',\n            legend.height = 0.2,\n            legend.width=0.4)\n\ntmap_arrange(lag_gdppc, W_avg_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-68-1.png){width=1344}\n:::\n:::\n\n\n::: callout-note\nBoth charts use row-standardised spatial weights matrix.\n\nDifference between charts is that left does not include self's GDPPC but the right includes self's GDPPC.\n:::\n\n### **8.8.4 Spatial window sum**\n\nThe spatial window sum is the counter part of the window average, but without using row-standardized weights. (similar to 8.8.2 but including self)\n\nTo add the diagonal element to the neighbour list, we just need to use *include.self()* from **spdep**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_qs <- include.self(wm_q)\nwm_qs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n```\n:::\n:::\n\n\nNext, we will assign binary **general** weights to the neighbour structure that includes the diagonal element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights <- lapply(wm_qs, function(x) 0*x + 1)\nb_weights[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 1 1 1 1 1\n\n[[2]]\n[1] 1 1 1 1 1 1\n\n[[3]]\n[1] 1 1 1 1 1\n```\n:::\n:::\n\n\nEach spatial unit has one more element, that is itself.\n\nAgain, we use *`nb2listw()`* and `wm_qs` (nb structure) and `b_weights` (glist) to create **spatial** weights matrix `b_weights`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights2 <- nb2listw(wm_qs, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0   S1    S2\nB 88 7744 536 1072 14160\n```\n:::\n:::\n\n\nCompute the window sum lag variable using `lag.listw()`, `b_weights2` (spatial weights matrix) and `hunan$GDPCC` (variable). The below also appends the window sum lag variable to `hunan` df.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nstr(w_sum_gdppc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ : chr [1:88] \"Anxiang\" \"Hanshou\" \"Jinshi\" \"Li\" ...\n $ : num [1:88] 147903 134605 131165 135423 134635 ...\n```\n:::\n\n```{.r .cell-code}\nw_sum_gdppc.res <- as.data.frame(w_sum_gdppc)\ncolnames(w_sum_gdppc.res) <- c(\"NAME_3\", \"w_sum GDPPC\")\n\nhunan <- left_join(hunan, w_sum_gdppc.res)\nhunan %>%\n  select(\"County\", \"lag_sum GDPPC\", \"w_sum GDPPC\") %>%\n  head() %>% \n  kable()\n```\n\n::: {.cell-output-display}\n|County  | lag_sum GDPPC| w_sum GDPPC|geometry                       |\n|:-------|-------------:|-----------:|:------------------------------|\n|Anxiang |        124236|      147903|POLYGON ((112.0625 29.75523... |\n|Hanshou |        113624|      134605|POLYGON ((112.2288 29.11684... |\n|Jinshi  |         96573|      131165|POLYGON ((111.8927 29.6013,... |\n|Li      |        110950|      135423|POLYGON ((111.3731 29.94649... |\n|Linli   |        109081|      134635|POLYGON ((111.6324 29.76288... |\n|Shimen  |        106244|      133381|POLYGON ((110.8825 30.11675... |\n:::\n:::\n\n\nLastly, *qtm()* of **tmap** package is used to plot the lag_sum GDPPC and w_sum_gdppc maps next to each other for quick comparison.\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nW_sum_gdppc <- qtm(hunan, 'w_sum GDPPC') +\n  tm_layout(main.title='With lag_win_sum variable',\n            legend.height = 0.2,\n            legend.width=0.4)\n\ntmap_arrange(lag_sum_gdppc, W_sum_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-73-1.png){width=1344}\n:::\n:::\n\n\n::: callout-note\nBoth charts do not use row-standardised spatial matrix, instead they use binary '1' because of the need to sum up the GDPPC values. Difference is that left does not include self but right includes self.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| eval: false\n#| echo: false\n#| fig-width: 14\n#| fig-asp: 0.68\n#| code-fold: True\n```\n:::\n\n\n## Summaries\n\nSummary of deriving spatial weights matrix\n\n![](images/Summary%20of%20deriving%20weights%20matrix.png)\n",
    "supporting": [
      "Hands-on_Ex2_1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}