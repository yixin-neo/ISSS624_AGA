{
  "hash": "9b3f18de560f606b578a3552e4c58e79",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Exercise 2.1: Spatial Weights and Applications\"\nauthor: \"NeoYX\"\ndate: '20 Nov 2023'\ndate-modified: \"2023-11-20\"\neditor: visual\nexecute: \n  freeze: auto\n  warning: false\n  #echo: false\n  #message: false\nformat: \n  html:\n    code-fold: false\n    code-overflow: scroll\n    code-summary: \"Show the code\"\n    code-line-numbers: true\n---\n\n\n## **8.1 Overview**\n\nIn this hands-on exercise, we will learn how to compute spatial weights using R. By the end to this hands-on exercise, we will be able to:\n\n-   import geospatial data using appropriate function(s) of **sf** package,\n\n-   import csv file using appropriate function of **readr** package,\n\n-   perform relational join using appropriate join function of **dplyr** package,\n\n-   compute spatial weights using appropriate functions of **spdep** package, and\n\n-   calculate spatially lagged variables using appropriate functions of **spdep** package.\n\n## **8.2 The Study Area and Data**\n\nTwo data sets will be used in this hands-on exercise, they are:\n\n-   Hunan county boundary layer. This is a geospatial data set in ESRI shapefile format.\n\n-   Hunan_2012.csv: This csv file (aspatial) contains selected Hunan's local development indicators in 2012.\n\n### **8.2.1 Getting Started**\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse, knitr)\n```\n:::\n\n\n## **8.3 Getting the Data Into R Environment**\n\n**8.3.1 Import shapefile into r environment**\n\nThe code chunk below uses [*st_read()*](https://r-spatial.github.io/sf/reference/st_read.html) of **sf** package to import Hunan shapefile into R. The imported shapefile will be **simple features** Object of **sf**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn='data/geospatial',\n                 layer = 'Hunan')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Hunan' from data source \n  `C:\\yixin-neo\\ISSS624_AGA\\Hands-on_Ex2\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n\n```{.r .cell-code}\nclass(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"data.frame\"\n```\n:::\n:::\n\n\n`hunan` is in WSG84 coordinate system.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hunan,3) %>% kable()\n```\n\n::: {.cell-output-display}\n|NAME_2  |  ID_3|NAME_3  |ENGTYPE_3   | Shape_Leng| Shape_Area|County  |geometry                       |\n|:-------|-----:|:-------|:-----------|----------:|----------:|:-------|:------------------------------|\n|Changde | 21098|Anxiang |County      |   1.869074|  0.1005619|Anxiang |POLYGON ((112.0625 29.75523... |\n|Changde | 21100|Hanshou |County      |   2.360691|  0.1997875|Hanshou |POLYGON ((112.2288 29.11684... |\n|Changde | 21101|Jinshi  |County City |   1.425620|  0.0530241|Jinshi  |POLYGON ((111.8927 29.6013,... |\n:::\n:::\n\n\n### **8.3.2 Import csv file into r environment**\n\nNext, we will import *Hunan_2012.csv* into R by using *read_csv()* of **readr** package. The output is R dataframe class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv('data/aspatial/Hunan_2012.csv')\nhead(hunan2012,3) %>% kable()\n```\n\n::: {.cell-output-display}\n|County  |City     | avg_wage| deposite|    FAI| Gov_Rev| Gov_Exp|     GDP| GDPPC|    GIO|   Loan|  NIPCR|  Bed|    Emp|  EmpR| EmpRT| Pri_Stu| Sec_Stu| Household| Household_R| NOIP| Pop_R|   RSCG| Pop_T|     Agri| Service| Disp_Inc|      RORP|    ROREmp|\n|:-------|:--------|--------:|--------:|------:|-------:|-------:|-------:|-----:|------:|------:|------:|----:|------:|-----:|-----:|-------:|-------:|---------:|-----------:|----:|-----:|------:|-----:|--------:|-------:|--------:|---------:|---------:|\n|Anhua   |Yiyang   |    30544|  10967.0| 6831.7|  456.72|  2703.0| 13225.0| 14567| 9276.9| 3954.9| 3528.3| 2718| 494.31| 441.4| 338.0|  54.175|  32.830|     290.4|       234.5|  101| 670.3| 5760.6| 910.8| 4942.253|  5414.5|    12373| 0.7359464| 0.8929619|\n|Anren   |Chenzhou |    28058|   4598.9| 6386.1|  220.57|  1454.7|  4941.2| 12761| 4189.2| 2555.3| 3271.8|  970| 290.82| 255.4|  99.4|  33.171|  17.505|     104.6|       121.9|   34| 243.2| 2386.4| 388.7| 2357.764|  3814.1|    16072| 0.6256753| 0.8782065|\n|Anxiang |Changde  |    31935|   5517.2| 3541.0|  243.64|  1779.5| 12482.0| 23667| 5108.9| 2806.9| 7693.7| 1931| 336.39| 270.5| 205.9|  19.584|  17.819|     148.1|       135.4|   53| 346.0| 3957.9| 528.3| 4524.410| 14100.0|    16610| 0.6549309| 0.8041262|\n:::\n:::\n\n\n### **8.3.3 Performing relational join**\n\nThe code chunk below will be used to update the attribute table of *hunan*'s SpatialPolygonsDataFrame with the attribute fields of *hunan2012* dataframe. This is performed by using *left_join()* of **dplyr** package.\n\nAs the join columns are not specified, this function will assume that columns with the same names, e.g., 'county' in both dfs will be the join columns.\n\nThe select() will retain the columns indicated in the resulting joined df.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, hunan2012) %>% \n  select(1:4,7,15)\nclass(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"data.frame\"\n```\n:::\n:::\n\n\nNote the geospatial characteristics of hunan is retained.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hunan,3) %>% kable\n```\n\n::: {.cell-output-display}\n|NAME_2  |  ID_3|NAME_3  |ENGTYPE_3   |County  | GDPPC|geometry                       |\n|:-------|-----:|:-------|:-----------|:-------|-----:|:------------------------------|\n|Changde | 21098|Anxiang |County      |Anxiang | 23667|POLYGON ((112.0625 29.75523... |\n|Changde | 21100|Hanshou |County      |Hanshou | 20981|POLYGON ((112.2288 29.11684... |\n|Changde | 21101|Jinshi  |County City |Jinshi  | 34592|POLYGON ((111.8927 29.6013,... |\n:::\n:::\n\n\n## **8.4 Visualising Regional Development Indicator**\n\nNow, we are going to prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using *qtm()* of **tmap** package.\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nbasemap <- tm_shape(hunan)+\n  tm_polygons() +\n  tm_text('NAME_3',\n          size = 0.5)\n\ngdppc <- tm_shape(hunan)+\n  tm_polygons('GDPPC') +\n    tm_layout(legend.height = 0.20, \n            legend.width = 0.25)\n  \n\ntmap_arrange(basemap, gdppc,\n           asp=1,\n           ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-7-1.png){width=1344}\n:::\n:::\n\n\n## **8.5 Computing Contiguity Spatial Weights**\n\nIn this section, we will use [*poly2nb()*](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package to compute contiguity weight matrices for the study area. This function builds a neighbours list based on regions with contiguous boundaries.\n\nBy default, 'queen' argument is set to TRUE: two polygons sharing one shared boundary point will meet contiguity condition. Returns a list of first order neighbours using the Queen criteria.\n\nIf 'queen' argument is set to FALSE: requires more than one shared boundary point. (but may not mean a shared boundary line)\n\n### **8.5.1 Computing (QUEEN) contiguity based neighbours**\n\nThe code chunk below is used to compute Queen contiguity weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n:::\n:::\n\n\nThe summary report above shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours. There are two area units with only one heighbours.\n\n`wm_q` (weights matrix queen) 's class\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"nb\"\n```\n:::\n:::\n\n\nA quick peak at `wm_q`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(wm_q,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1]  2  3  4 57 85\n\n[[2]]\n[1]  1 57 58 78 85\n\n[[3]]\n[1]  1  4  5 85\n```\n:::\n:::\n\n\nFor each polygon in our polygon object, *wm_q* lists all neighboring polygons. For example, to see the neighbors for the first polygon in the object, type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  3  4 57 85\n```\n:::\n:::\n\n\nPolygon 1 has 5 neighbors. The numbers represent the polygon IDs as stored in hunan SpatialPolygonsDataFrame class.\n\nWe can retrive the county name of Polygon ID=1 by using the code chunk below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan$County[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Anxiang\"\n```\n:::\n:::\n\n\nPolygon ID=1 is Anxiang county.\n\nTo reveal the county names of the five neighboring polygons, the code chunk will be used:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- wm_q[[1]]\nhunan$County[c(x1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n```\n:::\n:::\n\n\nThe printed output above shows that the GDPPC of the five nearest neighbours based on Queen\\'s method are 20981, 34592, 24473, 21311 and 22879 respectively.\n\nTo display the complete weight matrix, use *str()*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"sym\")= logi TRUE\n```\n:::\n\n```{.r .cell-code}\n#wm_q[1:10]\n#methods(class = class(wm_q))\n```\n:::\n\n\n### **8.5.2 Creating (ROOK) contiguity based neighbours**\n\nThe code chunk below is used to compute Rook contiguity weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n```\n:::\n:::\n\n\nThe summary report above shows that there are 88 area units in Hunan. The most connect area unit has 10 neighbours. There are two area units with only one heighbours.\n\n### 8.5.3 Visualising contiguity weights (find centroid coords first)\n\nA connectivity graph takes a point and displays a line to each neighbouring point.\n\n-   need a point in polygon via polygon centroids (its lat & long) \\<- calculate using the sf package first\n\nTo obtain coordinates in a separate data frame\n\n1.  input vector is the geometry column of us.bound (in `hunan`), an sf object \\<- a polygon\n\n    Using hunan\\$geometry\\[\\[1\\]\\]: The input vector of the FIRST POLYGON looks like POLYGON ((112.0625 29.75523, 112.069 29.74544, 112.0707 29.7415, 112.0716 29.73667, .... , 112.0625 29.75523).\n\n2.  To find the centroid (CG) of one polygon, use the `st_centroid()` function, which is a formula shorthand for a small anonymous function (lambda function). It takes an argument represented by **`.x`**.\n    `st_centroid(.x)[[1]]` extracts the X-coordinate (longitude) of the centroid while `st_centroid(.x)[[2]]` extracts the Y-coords.\n\n    ::: panel-tabset\n    #### X and Y\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    #hunan$geometry[[1]]\n    st_centroid(hunan$geometry[[1]])\n    ```\n    :::\n\n\n    #### X only\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    st_centroid(hunan$geometry[[1]])[[1]]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 112.1531\n    ```\n    :::\n    :::\n\n\n    #### Y only\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    st_centroid(hunan$geometry[[1]])[[2]]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 29.44362\n    ```\n    :::\n    :::\n\n    :::\n\n**`map_dbl(...)`** is a function from the **`purrr`** package that applies a function to each element of a list or vector and returns the results as a double vector. In this case, the function being applied is the expression following **`~`**.\nExample of how this function is used in a simple way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example list of vectors\nlist_of_vectors <- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))\n\n# Applying a function to calculate the sum of each vector\nmap_dbl(list_of_vectors, ~ sum(.x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n a  b  c \n 6 15 24 \n```\n:::\n:::\n\n\nAfter finding centroid, to access longitude values\n\n-   double bracket notation \\[\\[ \\]\\] and 1\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n    longitude\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n     [1] 112.1531 112.0372 111.8917 111.7031 111.6138 111.0341 113.7065 112.3460\n     [9] 112.8169 113.3534 113.8942 112.4006 112.5542 113.6636 112.9206 113.1883\n    [17] 113.4521 112.4209 113.0152 112.6350 112.7087 112.9095 111.9522 110.2606\n    [25] 110.0921 109.7985 109.5765 109.7211 109.7339 109.1537 110.6442 110.5916\n    [33] 109.5984 111.4783 112.1745 111.2315 110.3149 111.3248 110.5859 110.9593\n    [41] 111.8296 110.1926 110.7334 110.9123 111.4599 112.5268 112.3406 109.5602\n    [49] 109.5071 109.9954 109.4273 109.7587 109.5044 109.9899 109.9664 111.3785\n    [57] 112.4350 112.5558 111.7379 112.1831 111.9743 111.7009 112.2196 112.6472\n    [65] 113.5102 113.1172 113.7089 112.7963 110.9276 113.6420 113.4577 113.8404\n    [73] 113.4758 113.1428 110.3017 113.1957 111.7410 112.1831 111.3390 111.8208\n    [81] 110.0753 112.3965 112.7683 113.1679 111.4495 112.7956 111.5896 111.2393\n    ```\n    :::\n    :::\n\n\nTo access the latitude value\n\n-   double bracket notation \\[\\[ \\]\\] and 2\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n    ```\n    :::\n\n\nWith both longitude and latitude, use cbind() to combine both in the same object,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- cbind(longitude, latitude)\nhead(coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n```\n:::\n:::\n\n\n#### 8.5.3.1 Plotting Queen contiguity based neighbours map\n\nwm\\_ q is weight matrix using queen method (88 rows of list of neighbours)\n\ncoords is an array of x,y coordinates of centroids for each of the 88 counties\n\n\n::: {.cell fig.asp='0.6'}\n\n```{.r .cell-code}\nplot(hunan$geometry, border=\"lightgrey\", main=\"Queen's contiguity\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-23-1.png){width=1344}\n:::\n:::\n\n\n> Use the [plot()](https://www.digitalocean.com/community/tutorials/plot-function-in-r) function\n>\n> 1.  **The shape of the markers:** The plot markers are by default small, empty circles. These are also known as plot characters - denoted by **pch**. Pch values 0 to 25 are valid and give several different symbols on the graph. **Pch** 0 is for a square, 1 is for a circle, 3 is for a triangle, 4 is for a cross and so on.\n>\n> 2.  **Size of the plot markers**: The **cex** parameter can be set to 0.5 if we want the markers to be 50% smaller and 1.5 if wewant them to be 50% larger.\n>\n> 3.  **Color of the plot markers:** These colors can be selected from a list provided by R under the `colors()` function.\n\n#### 8.5.3.2 Plotting Rook contiguity based neighbours map\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nplot(hunan$geometry, border = 'lightgrey', main='Rooks contiguity')\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col =\"blue\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-24-1.png){width=1344}\n:::\n:::\n\n\n#### 8.5.3.3 Plotting both Queen and Rook contiguity based neighbours maps side-by-side\n\n`par(mfrow = c(1, 2))` arranges subsequent plots in a grid with **one** row and **two** columns\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\n\nplot(hunan$geometry, border=\"lightgrey\", main=\"Queen's contiguity\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\", main=\"Queen Contiguity\")\nplot(hunan$geometry, border=\"lightgrey\",main=\"Rook's contiguity\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"blue\", main=\"Rook Contiguity\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_1_files/figure-html/unnamed-chunk-25-1.png){width=1344}\n:::\n:::\n\n\n## 8.6 Computing distance based neighbours\n\n-   In this section, we will derive distance-based weight matrices by using [*dnearneigh()*](https://r-spatial.github.io/spdep/reference/dnearneigh.html) of **spdep** package.\n\n    | dnearneigh(x, d1, d2, row.names = NULL, longlat = NULL, bounds=c(\"GE\", \"LE\"),\n    |  use_kd_tree=TRUE, symtest=FALSE, use_s2=packageVersion(\"s2\") \\> \"1.0.7\", k=200,\n    |  dwithin=TRUE)\n\n-   identifies neighbours using distance band with lower d1= and upper d2= bounds controlled by the `bounds=` argument\n\n-   If unprojected coordinates are used (WSG84 geographic) and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in **km** will be calculated assuming the WGS84 reference ellipsoid.\n\n### **8.6.1 Determine the cut-off distance**\n\nFirstly, we need to determine the upper limit for distance band by using the steps below:\n\n-   Return a **matrix** with the indices of points belonging to the set of the k nearest neighbours of each other by using [*knearneigh()*](https://r-spatial.github.io/spdep/reference/knearneigh.html) of **spdep**. **Class: 'knn'**.\n    Output: NN of poly1 = poly3, NN of poly2 = poly 78 etc...\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    str(knearneigh(coords,\n               k=1))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    List of 5\n     $ nn       : int [1:88, 1] 3 78 1 5 4 69 67 46 84 70 ...\n     $ np       : int 88\n     $ k        : num 1\n     $ dimension: int 2\n     $ x        : num [1:88, 1:2] 112 112 112 112 112 ...\n      ..- attr(*, \"dimnames\")=List of 2\n      .. ..$ : NULL\n      .. ..$ : chr [1:2] \"longitude\" \"latitude\"\n     - attr(*, \"class\")= chr \"knn\"\n     - attr(*, \"call\")= language knearneigh(x = coords, k = 1)\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    #knearneigh(coords,k=1)['nn']  #<< shows matrix\n    ```\n    :::\n\n\n-   Convert the matrix knn object returned by *knearneigh()* into a neighbours **list** with a list of integer vectors containing neighbour region number ids by using [*knn2nb()*](https://r-spatial.github.io/spdep/reference/knn2nb.html). **Class: nb**\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    knn2nb(knearneigh(coords))[1:5]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [[1]]\n    [1] 3\n    \n    [[2]]\n    [1] 78\n    \n    [[3]]\n    [1] 1\n    \n    [[4]]\n    [1] 5\n    \n    [[5]]\n    [1] 4\n    ```\n    :::\n    :::\n\n\n-   Return a list of the **length** (the distance to one\\'s nearest neighbour) of neighbour relationship edges by using [*nbdists()*](https://r-spatial.github.io/spdep/reference/nbdists.html) of **spdep**. The function returns in the units of the coordinates if the coordinates are projected, in km if in WSG84. **Class: 'nbdist'**\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    nbdists(knn2nb(knearneigh(coords)),\n            coords,\n            longlat = TRUE) [1:5]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [[1]]\n    [1] 25.53398\n    \n    [[2]]\n    [1] 43.03114\n    \n    [[3]]\n    [1] 25.53398\n    \n    [[4]]\n    [1] 29.2848\n    \n    [[5]]\n    [1] 29.2848\n    ```\n    :::\n    :::\n\n\n-   Remove the list structure of the returned object by using [**unlist()**](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/unlist). **Class of k1dists: numeric.**\n\n    Output: 25.53398 43.03114 25.53398 29.28480 29.28480 45.98097 58.52704 28.95985 34.45062 37.99885 44.49442 33.48816 35.98123\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    k1 <- knn2nb(knearneigh(coords))\n    k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\n    summary(k1dists)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n       Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n      24.79   32.57   38.01   39.07   44.52   61.79 \n    ```\n    :::\n    :::\n\n\n**The summary report shows that the largest first nearest neighbour distance is 61.79. So using this as the upper threshold (62km) will help to ensure that all units (polygons) will have at least one neighbour**.\n\n### 8.6.2 Computing [fixed]{.underline} distance weight matrix\n\n(Earlier, we had used `poly2nb(hunan, queen=TRUE/FALSE)` to define neighbours using Queen or Rook method, resulting in `wm_q` and `wm_r`)\n\nNow, to define neighbours using distance, we use the `dnearneigh()` ,\n\n-   *longlat argument: TRUE if point coordinates are **geographical** longitude-latitude decimal degrees (WSG84)*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_d62 <- dnearneigh(coords, 0, 62, longlat=TRUE )\nwm_d62\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n```\n:::\n:::\n\n\nAverage number of links is calculated by dividing the total number of links by the number of regions. On average, each region has approximately 3.68 neighboring regions.\n\nNext, we will use *str()* to display the content of wm_d62 weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(wm_d62)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 88\n $ : int [1:5] 3 4 5 57 64\n $ : int [1:4] 57 58 78 85\n $ : int [1:4] 1 4 5 57\n $ : int [1:3] 1 3 5\n $ : int [1:4] 1 3 4 85\n $ : int 69\n $ : int [1:2] 67 84\n $ : int [1:4] 9 46 47 78\n $ : int [1:4] 8 46 68 84\n $ : int [1:4] 16 22 70 72\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:2] 11 17\n $ : int 13\n $ : int [1:4] 10 17 22 83\n $ : int [1:3] 11 14 16\n $ : int [1:3] 20 22 63\n $ : int [1:5] 20 21 73 74 82\n $ : int [1:5] 18 19 21 22 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:4] 10 16 18 20\n $ : int [1:3] 41 77 82\n $ : int [1:4] 25 28 31 54\n $ : int [1:4] 24 28 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:2] 26 29\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:2] 27 37\n $ : int 33\n $ : int [1:2] 24 36\n $ : int 50\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:5] 31 34 45 56 80\n $ : int [1:2] 29 42\n $ : int [1:3] 44 77 79\n $ : int [1:4] 40 42 43 81\n $ : int [1:3] 39 45 79\n $ : int [1:5] 23 35 45 79 82\n $ : int [1:5] 26 37 39 43 81\n $ : int [1:3] 39 42 44\n $ : int [1:2] 38 43\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:5] 8 9 35 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:4] 48 49 50 52\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:2] 48 55\n $ : int [1:5] 24 28 49 50 52\n $ : int [1:4] 48 50 53 75\n $ : int 36\n $ : int [1:5] 1 2 3 58 64\n $ : int [1:5] 2 57 64 66 68\n $ : int [1:3] 60 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:5] 12 60 62 63 87\n $ : int [1:4] 61 63 77 87\n $ : int [1:5] 12 18 61 62 83\n $ : int [1:4] 1 57 58 76\n $ : int 76\n $ : int [1:5] 58 67 68 76 84\n $ : int [1:2] 7 66\n $ : int [1:4] 9 58 66 84\n $ : int [1:2] 6 75\n $ : int [1:3] 10 72 73\n $ : int [1:2] 73 74\n $ : int [1:3] 10 11 70\n $ : int [1:4] 19 70 71 74\n $ : int [1:5] 19 21 71 73 86\n $ : int [1:2] 55 69\n $ : int [1:3] 64 65 66\n $ : int [1:3] 23 38 62\n $ : int [1:2] 2 8\n $ : int [1:4] 38 40 41 45\n $ : int [1:5] 34 35 36 45 47\n $ : int [1:5] 25 26 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:4] 12 13 16 63\n $ : int [1:4] 7 9 66 68\n $ : int [1:2] 2 5\n $ : int [1:4] 21 46 47 74\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 62, longlat = TRUE)\n - attr(*, \"dnn\")= num [1:2] 0 62\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE\n```\n:::\n:::\n\n\nAnother way to display the structure of the weight matrix is to combine [*table()*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/table) and [*card()*](https://r-spatial.github.io/spdep/reference/card.html) of spdep.\n\nThe column headers \"1\" means the count of counties that have 1 neighbor within the specified distance of 62km, \"2\" means the count of counties that have 2 neighbors, and so on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(hunan$County, card(wm_d62))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               \n                1 2 3 4 5 6\n  Anhua         1 0 0 0 0 0\n  Anren         0 0 0 1 0 0\n  Anxiang       0 0 0 0 1 0\n  Baojing       0 0 0 0 1 0\n  Chaling       0 0 1 0 0 0\n  Changning     0 0 1 0 0 0\n  Changsha      0 0 0 1 0 0\n  Chengbu       0 1 0 0 0 0\n  Chenxi        0 0 0 1 0 0\n  Cili          0 1 0 0 0 0\n  Dao           0 0 0 1 0 0\n  Dongan        0 0 1 0 0 0\n  Dongkou       0 0 0 1 0 0\n  Fenghuang     0 0 0 1 0 0\n  Guidong       0 0 1 0 0 0\n  Guiyang       0 0 0 1 0 0\n  Guzhang       0 0 0 0 0 1\n  Hanshou       0 0 0 1 0 0\n  Hengdong      0 0 0 0 1 0\n  Hengnan       0 0 0 0 1 0\n  Hengshan      0 0 0 0 0 1\n  Hengyang      0 0 0 0 0 1\n  Hongjiang     0 0 0 0 1 0\n  Huarong       0 0 0 1 0 0\n  Huayuan       0 0 0 1 0 0\n  Huitong       0 0 0 1 0 0\n  Jiahe         0 0 0 0 1 0\n  Jianghua      0 0 1 0 0 0\n  Jiangyong     0 1 0 0 0 0\n  Jingzhou      0 1 0 0 0 0\n  Jinshi        0 0 0 1 0 0\n  Jishou        0 0 0 0 0 1\n  Lanshan       0 0 0 1 0 0\n  Leiyang       0 0 0 1 0 0\n  Lengshuijiang 0 0 1 0 0 0\n  Li            0 0 1 0 0 0\n  Lianyuan      0 0 0 0 1 0\n  Liling        0 1 0 0 0 0\n  Linli         0 0 0 1 0 0\n  Linwu         0 0 0 1 0 0\n  Linxiang      1 0 0 0 0 0\n  Liuyang       0 1 0 0 0 0\n  Longhui       0 0 1 0 0 0\n  Longshan      0 1 0 0 0 0\n  Luxi          0 0 0 0 1 0\n  Mayang        0 0 0 0 0 1\n  Miluo         0 0 0 0 1 0\n  Nan           0 0 0 0 1 0\n  Ningxiang     0 0 0 1 0 0\n  Ningyuan      0 0 0 0 1 0\n  Pingjiang     0 1 0 0 0 0\n  Qidong        0 0 1 0 0 0\n  Qiyang        0 0 1 0 0 0\n  Rucheng       0 1 0 0 0 0\n  Sangzhi       0 1 0 0 0 0\n  Shaodong      0 0 0 0 1 0\n  Shaoshan      0 0 0 0 1 0\n  Shaoyang      0 0 0 1 0 0\n  Shimen        1 0 0 0 0 0\n  Shuangfeng    0 0 0 0 0 1\n  Shuangpai     0 0 0 1 0 0\n  Suining       0 0 0 0 1 0\n  Taojiang      0 1 0 0 0 0\n  Taoyuan       0 1 0 0 0 0\n  Tongdao       0 1 0 0 0 0\n  Wangcheng     0 0 0 1 0 0\n  Wugang        0 0 1 0 0 0\n  Xiangtan      0 0 0 1 0 0\n  Xiangxiang    0 0 0 0 1 0\n  Xiangyin      0 0 0 1 0 0\n  Xinhua        0 0 0 0 1 0\n  Xinhuang      1 0 0 0 0 0\n  Xinning       0 1 0 0 0 0\n  Xinshao       0 0 0 0 0 1\n  Xintian       0 0 0 0 1 0\n  Xupu          0 1 0 0 0 0\n  Yanling       0 0 1 0 0 0\n  Yizhang       1 0 0 0 0 0\n  Yongshun      0 0 0 1 0 0\n  Yongxing      0 0 0 1 0 0\n  You           0 0 0 1 0 0\n  Yuanjiang     0 0 0 0 1 0\n  Yuanling      1 0 0 0 0 0\n  Yueyang       0 0 1 0 0 0\n  Zhijiang      0 0 0 0 1 0\n  Zhongfang     0 0 0 1 0 0\n  Zhuzhou       0 0 0 0 1 0\n  Zixing        0 0 1 0 0 0\n```\n:::\n:::\n\n\nTO find the number of connected components (aka see if there are any spatial units / regions without a neighbour)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_comp <- n.comp.nb(wm_d62)\nn_comp$nc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nIn this connect component, there are 88 elements (spatial units)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(n_comp$comp.id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n 1 \n88 \n```\n:::\n:::\n\n::: {.cell fig.asp='0.68'}\n\n:::\n\n\n## Theories\n\n### \n",
    "supporting": [
      "Hands-on_Ex2_1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}