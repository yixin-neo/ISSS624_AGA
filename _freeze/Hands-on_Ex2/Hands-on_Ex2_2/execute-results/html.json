{
  "hash": "068c0a05880726ed9685842da6bda721",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Exercise 2.2 and 2.3: Global and Local Measures of Spatial Autocorrelation\"\nauthor: \"NeoYX\"\ndate: '22 Nov 2023'\ndate-modified: \"2023-11-23\"\neditor: visual\nexecute: \n  freeze: auto\n  warning: false\n  #echo: false\n  #message: false\nformat: \n  html:\n    code-fold: false\n    code-overflow: scroll\n    code-summary: \"Show the code\"\n    code-line-numbers: true\n---\n\n\n## **9.1 Overview**\n\nIn this hands-on exercise, we will learn to\n\n-   compute Global Spatial Autocorrelation (GSA) statistics by using appropriate functions of **spdep** package,\n\n    -   plot Moran scatterplot,\n\n    -   compute and plot spatial correlogram using appropriate function of **spdep** package.\n\n-   compute Local Indicator of Spatial Association (LISA) statistics for detecting clusters and outliers by using appropriate functions **spdep** package;\n\n-   compute Getis-Ord's Gi-statistics for detecting hot spot or/and cold spot area by using appropriate functions of **spdep** package; and\n\n-   to visualise the analysis output by using **tmap** package.\n\n# 9 Hands-on_EX2_2: Global measures of spatial autocorrelation\n\n## **9.2 Getting Started**\n\n### 9.2.1 The analytical question\n\n-   In spatial policy, local government/planners aims to ensure equal distribution of development in the province.\n\n-   we should apply appropriate spatial statistical methods to discover if development are even distributed geographically in the province\n\n-   if answer is NO, we ask \"is there sign of clustering?\" (GLOBAL spatial autocorrelation)\n\n-   if YES, \"Where are the clusters\" (LOCAL spatial autocorrelation)\n\nIn this case study, we are interested to examine the spatial pattern of a selected development indicator (i.e. GDP per capita) of Hunan Provice, People Republic of China. (https://en.wikipedia.org/wiki/Hunan)\n\n### \n\n### 9.2.2 The Study Area and Data\n\nTwo data sets will be used in this hands-on exercise:\n\n1.  Geospatial data: Hunan province administrative boundary layer at county level in ESRI shapefile format\n\n2.  Aspatial data: *Hunan_2012.csv* containing local development indicators\n\n### 9.2.3 Setting the Analytical Tools\n\nPackages we need:\n\n-   sf is use for importing and handling geospatial data in R,\n\n-   tidyverse is mainly use for wrangling attribute data in R,\n\n-   spdep will be used to compute spatial weights, global and local spatial autocorrelation statistics, and\n\n-   tmap will be used to prepare cartographic quality chropleth map.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse, knitr)\n```\n:::\n\n\n## **9.3 Getting the Data Into R Environment**\n\nThe geospatial data is in ESRI shapefile format and the attribute table is in csv fomat.\n\n### **9.3.1 Import shapefile into r environment**\n\nThe code chunk below uses [*st_read()*](https://r-spatial.github.io/sf/reference/st_read.html) of **sf** package to import Hunan shapefile into R. The imported shapefile will be **simple features** Object of **sf**.\n\n`hunan` is in WSG84 geographical system.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn='data/geospatial',\n                 layer='Hunan')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Hunan' from data source \n  `C:\\yixin-neo\\ISSS624_AGA\\Hands-on_Ex2\\data\\geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n\n```{.r .cell-code}\n#st_crs(hunan)\nhead(hunan,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 3 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 111.7027 ymin: 28.61762 xmax: 112.3013 ymax: 29.77344\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3 Shape_Leng Shape_Area  County\n1 Changde 21098 Anxiang      County   1.869074 0.10056190 Anxiang\n2 Changde 21100 Hanshou      County   2.360691 0.19978745 Hanshou\n3 Changde 21101  Jinshi County City   1.425620 0.05302413  Jinshi\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n```\n:::\n:::\n\n\n### **9.3.2 Import csv file into r environment**\n\nNext, we will import *Hunan_2012.csv* into R by using *read_csv()* of **readr** package. The output is R data frame class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv('data/aspatial/Hunan_2012.csv')\nhead(hunan2012,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 29\n  County  City  avg_wage deposite   FAI Gov_Rev Gov_Exp    GDP GDPPC   GIO  Loan\n  <chr>   <chr>    <dbl>    <dbl> <dbl>   <dbl>   <dbl>  <dbl> <dbl> <dbl> <dbl>\n1 Anhua   Yiya…    30544   10967  6832.    457.   2703  13225  14567 9277. 3955.\n2 Anren   Chen…    28058    4599. 6386.    221.   1455.  4941. 12761 4189. 2555.\n3 Anxiang Chan…    31935    5517. 3541     244.   1780. 12482  23667 5109. 2807.\n# ℹ 18 more variables: NIPCR <dbl>, Bed <dbl>, Emp <dbl>, EmpR <dbl>,\n#   EmpRT <dbl>, Pri_Stu <dbl>, Sec_Stu <dbl>, Household <dbl>,\n#   Household_R <dbl>, NOIP <dbl>, Pop_R <dbl>, RSCG <dbl>, Pop_T <dbl>,\n#   Agri <dbl>, Service <dbl>, Disp_Inc <dbl>, RORP <dbl>, ROREmp <dbl>\n```\n:::\n:::\n\n\n### **9.3.3 Performing relational join**\n\nThe code chunk below will be used to update the attribute table of *hunan*'s SpatialPolygonsDataFrame (geospatial) with the attribute fields of *hunan2012* dataframe (aspatial) . This is performed by using *left_join()* of **dplyr** package. Since the join columns are not specified, identical columns names ('County') form both dataset will be used for the join.\n\nColumn 7 and 15 are the 'County' and 'GDPPC' columns respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, hunan2012) %>% \n  select(1:4, 7,15)\nhead(hunan,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 3 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 111.7027 ymin: 28.61762 xmax: 112.3013 ymax: 29.77344\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3  County GDPPC\n1 Changde 21098 Anxiang      County Anxiang 23667\n2 Changde 21100 Hanshou      County Hanshou 20981\n3 Changde 21101  Jinshi County City  Jinshi 34592\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n```\n:::\n:::\n\n\n### **9.3.4 Visualising Regional Development Indicator**\n\nNow, we are going to prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using *qtm()* of **tmap** package.\n\n-   tm_fill() 's **n** refer to the number of equal intervals\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nequal <- tm_shape(hunan)+\n  tm_fill('GDPPC',\n          n=5,\n          style='equal') +\n  tm_borders(alpha=0.5) +\n  tm_layout(main.title = 'Equal interval classification',\n            main.title.size=1.5,\n            legend.height = 0.25,\n            legend.width = 0.25)\n\nquantile <- tm_shape(hunan)+\n  tm_fill('GDPPC',\n          n=5,\n          style='quantile') +\n  tm_borders(alpha=0.5) +\n  tm_layout(main.title = 'Equal quantile classification',\n            main.title.size=1.5,\n            legend.height = 0.25,\n            legend.width = 0.25)\n\ntmap_arrange(equal, quantile, asp =1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-5-1.png){width=1344}\n:::\n:::\n\n\n## **9.4 Global Spatial Autocorrelation**\n\nIn this section, we will\n\n-   compute global spatial autocorrelation statistics\n\n-   perform spatial complete randomness test for global spatial autocorrelation (test for significance).\n\n### **9.4.1 Computing Contiguity Spatial Weights**\n\nBefore we can compute the global spatial autocorrelation statistics, we need to construct a spatial weights of the study area. The spatial weights is used to define the neighbourhood relationships between the geographical units (i.e. county) in the study area.\n\nIn the code chunk below, [*poly2nb()*](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package is used to compute contiguity weight matrices for the study area. This function will\n\n-   build a neighbours list based on regions with contiguous boundaries.\n\n-   if 'queen' argument is TRUE: spatial units are considered neighbours if they share a common point. A list of first order neighbours using the Queen criteria will be returned.\n\n-   if 'queen' argument is FALSE: spatial unit are considered neighbours if they share a least two common points.\n\nMore specifically, the code chunk below is used to compute Queen contiguity weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan,\n                queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n:::\n:::\n\n\nSneakpeak at the neighbours' list of the first three polygons.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1]  2  3  4 57 85\n\n[[2]]\n[1]  1 57 58 78 85\n\n[[3]]\n[1]  1  4  5 85\n```\n:::\n:::\n\n\nThe summary report above shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours. There are two area units with only one neighbours.\n\n### **9.4.2 Row-standardised weights matrix**\n\nNext, we need to assign weights to each neighboring polygon. In our case, each neighboring polygon will be assigned equal weight (style=\"W\"). This is accomplished by assigning the fraction 1/(#ofneighbors) to each neighboring county then summing the weighted income values. While this is the most intuitive way to summaries the neighbors' values it has one drawback in that polygons along the edges of the study area will base their lagged values on fewer polygons thus potentially over- or under-estimating the true nature of the spatial autocorrelation in the data. For this example, we'll stick with the style=\"W\" option for simplicity's sake but note that other more robust options are available, notably style=\"B\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q <- nb2listw(wm_q,\n                   style='W',\n                   zero.policy=TRUE)\nrswm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n:::\n:::\n\n\nSneak peak at the neighbour weights of the first three polygons\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q$weights[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 0.2 0.2 0.2 0.2 0.2\n\n[[2]]\n[1] 0.2 0.2 0.2 0.2 0.2\n\n[[3]]\n[1] 0.25 0.25 0.25 0.25\n```\n:::\n:::\n\n\nThe input of *nb2listw()* must be an object of class **nb**. The syntax of the function has two major arguments, namely style and zero.poly.\n\n-   *style* can take values \"W\", \"B\", \"C\", \"U\", \"minmax\" and \"S\". B is the basic binary coding, W is row standardised (sums over all links to n), C is globally standardised (sums over all links to n), U is equal to C divided by the number of neighbours (sums over all links to unity), while S is the variance-stabilizing coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168 (sums over all links to n).\n\n-   If *zero policy* is set to TRUE, weights vectors of zero length are inserted for regions without neighbour in the neighbours list. These will in turn generate lag values of zero, equivalent to the sum of products of the zero row t(rep(0, length=length(neighbours))) %\\*% x, for arbitrary numerical vector x of length length(neighbours). The spatially lagged value of x for the zero-neighbour region will then be zero, which may (or may not) be a sensible choice.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(rswm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"style\"      \"neighbours\" \"weights\"   \n\n$class\n[1] \"listw\" \"nb\"   \n\n$region.id\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\" \"14\" \"15\"\n[16] \"16\" \"17\" \"18\" \"19\" \"20\" \"21\" \"22\" \"23\" \"24\" \"25\" \"26\" \"27\" \"28\" \"29\" \"30\"\n[31] \"31\" \"32\" \"33\" \"34\" \"35\" \"36\" \"37\" \"38\" \"39\" \"40\" \"41\" \"42\" \"43\" \"44\" \"45\"\n[46] \"46\" \"47\" \"48\" \"49\" \"50\" \"51\" \"52\" \"53\" \"54\" \"55\" \"56\" \"57\" \"58\" \"59\" \"60\"\n[61] \"61\" \"62\" \"63\" \"64\" \"65\" \"66\" \"67\" \"68\" \"69\" \"70\" \"71\" \"72\" \"73\" \"74\" \"75\"\n[76] \"76\" \"77\" \"78\" \"79\" \"80\" \"81\" \"82\" \"83\" \"84\" \"85\" \"86\" \"87\" \"88\"\n\n$call\nnb2listw(neighbours = wm_q, style = \"W\", zero.policy = TRUE)\n```\n:::\n\n```{.r .cell-code}\nmethods(class=class(rswm_q))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] coerce      initialize  lag         plot        print       show       \n[7] slotsFromS3 subset      summary    \nsee '?methods' for accessing help and source code\n```\n:::\n:::\n\n\n### **9.4.3 Global Spatial Autocorrelation: Moran's I**\n\nIn this section, we will learn how to perform Moran's I statistics testing by using [*moran.test()*](https://r-spatial.github.io/spdep/reference/moran.test.html) of **spdep**.\n\n### **9.4.4 Moran's I test**\n\n**Global** spatial association assesses the overall spatial pattern of a variable across the entire study area. It provides a single value or metric that summarizes the extent to which similar values cluster together or are dispersed across the entire geographic space.\n\n**The Moran's I assumes data follows a normal distribution and are randomised.**\n\nMoran's I values range from -1 to 1 while Geary's C ranges from 0 to 2. The chart below summarises our lecture material.\n\n![](images/Global%20Moran%20stats%20test.png){width=\"357\"}\n\nThe code chunk below performs Moran's I statistical testing using [*moran.test()*](https://r-spatial.github.io/spdep/reference/moran.test.html) of **spdep**. It takes in the main arguments:\n\n-   variable\n\n-   `listw` , our spatial weights matrix that defines the neighbourhood and relationship between them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoran.test(hunan$GDPPC,\n           listw = rswm_q,\n           zero.policy=TRUE,\n           na.action=na.omit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMoran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n:::\n:::\n\n\n> The null hypothesis: Observed spatial patterns of values is equally likely as any random spatial pattern.\n>\n> Since the p-value is less than 0.05 and Moran I statistic is greater than 1, we can reject the null hypothesis and conclude that similar values tend to cluster together in our area of study.\n\n#### 9.4.4.1 Computing Monte Carlo Moran's I\n\nIn the event we are unsure whether the data follows a normal distribution and are randomised, we can use the Monte Carlo Simulation to simulate Moran's I [n]{.underline} times under the assumption of no spatial pattern (shuffle/permutate the variable across all spatial units). This creates a baseline to compare with the observed Moran's I value from dataset.\n\nThe code chunk below performs permutation test for Moran's I statistic by using [*moran.mc()*](https://r-spatial.github.io/spdep/reference/moran.mc.html) of **spdep**. A total of 1000 simulation will be performed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm = moran.mc(hunan$GDPPC,\n                 listw=rswm_q,\n                 nsim=999,\n                 zero.policy=TRUE,\n                 na.action=na.omit)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n:::\n:::\n\n\n| Since the p-value is less than 0.05 and Moran I statistic is greater than 1, we can reject the null hypothesis and conclude that similar values tend to cluster together in our area of study.\n\n#### 9.4.4.2 Visualising Monte Carlo Moran's I\n\nIt is always a good practice for us the examine the simulated Moran's I test statistics in greater detail. This can be achieved by plotting the distribution of the statistical values as a histogram by using the code chunk below.\n\nIn the code chunk below [*hist()*](https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/hist) and [*abline()*](https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/abline) of R Graphics are used.\n\nGet the mean of simulated moran's I values. The 'res' column contains the simulated moran's i values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999]) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.01504572\n```\n:::\n:::\n\n\nGet the variance\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.004371574\n```\n:::\n:::\n\n\nSummary statistics\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n```\n:::\n:::\n\n\nPlotting\n\n::: panel-tabset\n## ggplot2\n\nWe will use [ggplot2](https://ggplot2.tidyverse.org/) to create the histogram instead of base r.\n\n[**ggthemes**](https://cran.r-project.org/web/packages/ggthemes/) provides ['ggplot2' themes](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/) that replicate the look of plots by Edward Tufte, Stephen Few, [Fivethirtyeight](https://fivethirtyeight.com/), [The Economist](https://www.economist.com/graphic-detail), 'Stata', 'Excel', and [The Wall Street Journal](https://www.pinterest.com/wsjgraphics/wsj-graphics/), among others.\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(ggplot2)\nlibrary(ggthemes)\n\nbperm_df <- as.data.frame(bperm$res)\ncolnames(bperm_df) <- c('res')\n\n#q <- quantile(bperm_df$res[1:999], probs = c(0.25, 0.5, 0.75))\nmean <- mean(bperm_df$res[1:999])\nmean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.01504572\n```\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(data=bperm_df,\n       aes(x=res)) +\n  geom_histogram(bins=20,\n                 color='grey25',\n                 fill='grey90',size=0.8) +\n  #geom_vline(xintercept = q[2], linetype='dotted', size = 0.8, color='blue') +\n  #geom_vline(xintercept = q[3], linetype='dotted', size = 0.8) +\n  geom_vline(xintercept = mean, linetype='dotted', size = 0.8, color='red') +\n  #annotate('text' , x= -0.055, y=180, label='50th \\npercentile', size = 5, color='blue') +\n  #annotate('text' , x= 0.06, y=180, label='75th \\npercentile', size = 5) +\n  annotate('text' , x= 0.015, y=180, label='mean', size = 5, color='red') +\n  labs(y= 'Frequency', x=\"Moran's I values\") +\n  theme_economist() +\n  theme(axis.title.y=element_text(angle = 0,\n                                  vjust=0.9)) +\n  ggtitle(\"Histogram of Simulated Moran's I\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-16-1.png){width=1344}\n:::\n:::\n\n\n## Base Graph\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res,\n     freq=TRUE,\n     breaks=20,\n     xlab=\"Simulated Moran's I\",\n     main = paste(\"Histogram of Simulated Moran I\"))\nabline(v=0,\n       col='red')\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n:::\n\n### **9.4.5 Global Spatial Autocorrelation: Geary's**\n\nIn this section, we will learn how to perform Geary's c statistics testing by using appropriate functions of **spdep** package.\n\n#### 9.4.5.1 Geary's C test\n\nThe code chunk below performs Geary's C test for spatial autocorrelation by using [*geary.test()*](https://r-spatial.github.io/spdep/reference/geary.test.html) of **spdep**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeary.test(hunan$GDPPC, listw=rswm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tGeary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n```\n:::\n:::\n\n\n> The null hypothesis: Observed spatial patterns of values is equally likely as any random spatial pattern.\n>\n> Since the p-value is less than 0.05 and Geary's C statistic is greater 0 and less than 1, we can reject the null hypothesis and conclude that similar values tend to cluster together in our area of study.\n\n#### 9.4.5.2 Computing Monte Carlo Geary's C\n\nIn the event we are unsure whether the data follows a normal distribution and are randomised, the code chunk below performs permutation test for Geary's C statistic by using [*geary.mc()*](https://r-spatial.github.io/spdep/reference/geary.mc.html) of **spdep**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm=geary.mc(hunan$GDPPC, \n               listw=rswm_q, \n               nsim=999)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n```\n:::\n:::\n\n\n| Since the p-value is less than 0.05 and Geary's C statistic is greater 0 and less than 1, we can reject the null hypothesis and conclude that similar values tend to cluster together in our area of study.\n\n#### 9.4.5.3 Visualising the Monte Carlo Geary's C\n\nNext, we will plot a histogram to reveal the distribution of the simulated values by using the code chunk below.\n\nGet the mean of simulated Geary's C\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.004402\n```\n:::\n:::\n\n\nGet the variance\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.007436493\n```\n:::\n:::\n\n\nSummary statistics\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7142  0.9502  1.0052  1.0044  1.0595  1.2722 \n```\n:::\n:::\n\n\nPlot the histogram using ggplot2\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code  code-fold=\"true\"}\nbperm_df <- as.data.frame(bperm$res)\ncolnames(bperm_df) <- c('res')\n\n#q <- quantile(bperm_df$res[1:999], probs = c(0.25, 0.5, 0.75))\nmean <- mean(bperm_df$res[1:999])\nmean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.004402\n```\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(data=bperm_df,\n       aes(x=res)) +\n  geom_histogram(bins=20,\n                 color='grey25',\n                 fill='grey90',size=0.8) +\n  geom_vline(xintercept = mean, linetype='dotted', size = 0.8, color='red') +\n  annotate('text' , x= 1.05, y=180, label='mean', size = 5, color='red') +\n  labs(y= 'Frequency', x=\"Geary's C values\") +\n  theme_economist() +\n  theme(axis.title.y=element_text(angle = 0,\n                                  vjust=0.9)) +\n  ggtitle(\"Histogram of Simulated Geary's C\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-23-1.png){width=1344}\n:::\n:::\n\n\n## **9.5 Spatial Correlogram**\n\nSpatial correlograms are great to examine patterns of spatial autocorrelation in your data or model residuals. They show how correlated are pairs of spatial observations when you increase the distance (lag) between them - they are plots of some index of autocorrelation (Moran's I or Geary's c) against distance.Although correlograms are not as fundamental as variograms (a keystone concept of geostatistics), they are very useful as an exploratory and descriptive tool. For this purpose they actually provide richer information than variograms.\n\n### **9.5.1 Compute Moran's I correlogram**\n\nIn the code chunk below, [*sp.correlogram()*](https://r-spatial.github.io/spdep/reference/sp.correlogram.html) of **spdep** package is used to compute a 6-lag spatial correlogram of GDPPC. The global spatial autocorrelation used in Moran's I. The **plot()** of base Graph is then used to plot the output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMI_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"I\", \n                          style=\"W\")\nplot(MI_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\nArguments:\n\n-   'order' refers to number of layers away from each polygon using contiguity method. We want to check how the Moran's I values changes (and its statistical significance changes) as the neighbours get further and further away.\n\n-   'method': 'corr' for correlation, 'I' for Moran's I and 'C' for Gerary's C.\n\n| [Understanding the plot]{.underline}\n| **Y-Axis:** The y-axis typically represents the Moran's I coefficient, which quantifies spatial autocorrelation. Above zero, similar values cluster. Below zero, dissimilar values cluster.\n| **X-Axis:** The x-axis represents spatial distance lags. Each point on the correlogram corresponds to a specific distance lag (e.g., distance between observations). The points are usually organized in bins or distance classes.\n| **Bars or Lines:** Bars or lines connect the Moran's I values at different distance lags, forming a pattern that shows how spatial autocorrelation changes with distance.\n| [Usefulness of Moran's I Correlogram]{.underline}\n| **Detecting Spatial Patterns:** A Moran's I correlogram provides insights into the presence and structure of spatial patterns in our data. It helps identify at what distances spatial autocorrelation is significant.\n\nBy plotting the output might not allow us to provide complete interpretation. This is because not all autocorrelation values are statistically significant. Hence, it is important for us to examine the full analysis report by printing out the analysis results as in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(MI_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n\nWe see that with the exception of Lag 4, the rest of the results are statistically significant at the 95% level of confidence.\n\nAs we consider order lag from 1 to 3, there is significant positive autocorrelation (similar values cluster) and we note the Moran's I values decreases as order increases. For order 5 and 6, there is significant negative autocorrelation (dissimilar values cluster)\n\n[Possible reason for the change of polarity:]{.underline}\n\nLocal clusters could dominate at smaller distances while at larger distances, can detect dispersion more.\n\n**9.5.2 Compute Geary's C correlogram and plot**\n\nIn the code chunk below, *sp.correlogram()* of **spdep** package is used to compute a 6-lag spatial correlogram of GDPPC. The global spatial autocorrelation used in Geary's C. The **plot()** of base Graph is then used to plot the output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGC_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"C\", \n                          style=\"W\")\nplot(GC_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n0\\< Geary C \\< 1 : similar values cluster\n\n1 \\< Geary C \\< 2: dissimilar values cluster\n\nNow examine the full report to check which values are significant.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(GC_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n\nThe results of Geary's C statistics test is similar to Moran's I.\n\nAll lag orders except Lag order of 3, 4 and 6 are statistically significant at 95% confidence level.\n\nLag order 1 and 2: clustering of similar values, order 2 is less clustered than order 1. (Moran's I and Geary's C are inversely related.)\n\nLag order 5: clustering of dissimilar values.\n\n# \n\n# 10 Hands-on_Ex2_3: **Local Measures of Spatial Autocorrelation**\n\n## **10.6 Cluster and Outlier Analysis**\n\nLocal Indicators of Spatial Association or LISA are statistics that evaluate the existence of clusters in the spatial arrangement of a given variable. For instance if we are studying cancer rates among census tracts in a given city local clusters in the rates mean that there are **localised areas** that have higher or lower rates than is to be expected by chance alone; that is, the values occurring are above or below those of a random distribution in space.\n\nIn this section, we will learn how to apply appropriate Local Indicators for Spatial Association (LISA), especially local Moran'I to detect cluster (HH or LL) and/or outlier (HL, LH) from GDP per capita 2012 of Hunan Province, PRC.\n\n### **10.6.1 Computing local Moran's I**\n\nTo compute local Moran's I, the [*localmoran()*](https://r-spatial.github.io/spdep/reference/localmoran.html) function of **spdep** will be used. It computes ***Ii*** values, given a set of ***zi*** values (variable) and a **listw** object (spatial weights matrix) providing neighbour weighting information for the polygon associated with the zi values.\n\nThe code chunks below are used to compute local Moran's I of *GDPPC2012* at the county level.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfips <- order(hunan$County)\nlocalMI <- localmoran(hunan$GDPPC, rswm_q)\nhead(localMI)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Ii          E.Ii       Var.Ii        Z.Ii Pr(z != E(Ii))\n1 -0.001468468 -2.815006e-05 4.723841e-04 -0.06626904      0.9471636\n2  0.025878173 -6.061953e-04 1.016664e-02  0.26266425      0.7928094\n3 -0.011987646 -5.366648e-03 1.133362e-01 -0.01966705      0.9843090\n4  0.001022468 -2.404783e-07 5.105969e-06  0.45259801      0.6508382\n5  0.014814881 -6.829362e-05 1.449949e-03  0.39085814      0.6959021\n6 -0.038793829 -3.860263e-04 6.475559e-03 -0.47728835      0.6331568\n```\n:::\n:::\n\n\n*localmoran()* function returns a matrix of values whose columns are:\n\n-   Ii: the local Moran's I statistics\n\n-   E.Ii: the expectation of local moran statistic under the randomisation hypothesis\n\n-   Var.Ii: the variance of local moran statistic under the randomisation hypothesis\n\n-   Z.Ii:the standard deviate of local moran statistic\n\n-   Pr(z != E(Ii)): the p-value of local moran statistic\n\nNote there is no County's name in the output above.\n\nWe must first create a dataframe that appends the County's name to its local moran (li) values.\n\n-   Fips is an object of integer class. It contains the row ids if rows are to be arranged in alphabetical order.\n\n-   localMI\\[Fips,\\] would arrange the rows of `localMI` in alphabetical order of its countys' name, retaining all the columns.\n\n-   The row names would take the countys' name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(\n  localMI[fips,],\n  row.names=hunan$County[fips]) %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                     Ii          E.Ii       Var.Ii        Z.Ii Pr.z....E.Ii..\nAnhua     -2.249264e-02 -5.004845e-03 5.823550e-02 -0.07246715      0.9422301\nAnren     -3.993226e-01 -7.011066e-03 7.034768e-02 -1.47912938      0.1391057\nAnxiang   -1.468468e-03 -2.815006e-05 4.723841e-04 -0.06626904      0.9471636\nBaojing    3.473702e-01 -5.008916e-03 8.363556e-02  1.21846947      0.2230456\nChaling    2.055902e-02 -9.681197e-04 2.771090e-02  0.12931859      0.8971056\nChangning -2.986822e-05 -9.001050e-09 1.510502e-07 -0.07682771      0.9387606\n```\n:::\n:::\n\n\nThe code chunk below list the content of the local Moran matrix derived by using [*printCoefmat()*](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/printCoefmat).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprintCoefmat(data.frame(\n  localMI[fips,], \n  row.names=hunan$County[fips]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                       Ii        E.Ii      Var.Ii        Z.Ii Pr.z....E.Ii..\nAnhua         -2.2493e-02 -5.0048e-03  5.8235e-02 -7.2467e-02         0.9422\nAnren         -3.9932e-01 -7.0111e-03  7.0348e-02 -1.4791e+00         0.1391\nAnxiang       -1.4685e-03 -2.8150e-05  4.7238e-04 -6.6269e-02         0.9472\nBaojing        3.4737e-01 -5.0089e-03  8.3636e-02  1.2185e+00         0.2230\nChaling        2.0559e-02 -9.6812e-04  2.7711e-02  1.2932e-01         0.8971\nChangning     -2.9868e-05 -9.0010e-09  1.5105e-07 -7.6828e-02         0.9388\nChangsha       4.9022e+00 -2.1348e-01  2.3194e+00  3.3590e+00         0.0008\nChengbu        7.3725e-01 -1.0534e-02  2.2132e-01  1.5895e+00         0.1119\nChenxi         1.4544e-01 -2.8156e-03  4.7116e-02  6.8299e-01         0.4946\nCili           7.3176e-02 -1.6747e-03  4.7902e-02  3.4200e-01         0.7324\nDao            2.1420e-01 -2.0824e-03  4.4123e-02  1.0297e+00         0.3032\nDongan         1.5210e-01 -6.3485e-04  1.3471e-02  1.3159e+00         0.1882\nDongkou        5.2918e-01 -6.4461e-03  1.0748e-01  1.6338e+00         0.1023\nFenghuang      1.8013e-01 -6.2832e-03  1.3257e-01  5.1198e-01         0.6087\nGuidong       -5.9160e-01 -1.3086e-02  3.7003e-01 -9.5104e-01         0.3416\nGuiyang        1.8240e-01 -3.6908e-03  3.2610e-02  1.0305e+00         0.3028\nGuzhang        2.8466e-01 -8.5054e-03  1.4152e-01  7.7931e-01         0.4358\nHanshou        2.5878e-02 -6.0620e-04  1.0167e-02  2.6266e-01         0.7928\nHengdong       9.9964e-03 -4.9063e-04  6.7742e-03  1.2742e-01         0.8986\nHengnan        2.8064e-02 -3.2160e-04  3.7597e-03  4.6294e-01         0.6434\nHengshan      -5.8201e-03 -3.0437e-05  5.1076e-04 -2.5618e-01         0.7978\nHengyang       6.2997e-02 -1.3046e-03  2.1865e-02  4.3486e-01         0.6637\nHongjiang      1.8790e-01 -2.3019e-03  3.1725e-02  1.0678e+00         0.2856\nHuarong       -1.5389e-02 -1.8667e-03  8.1030e-02 -4.7503e-02         0.9621\nHuayuan        8.3772e-02 -8.5569e-04  2.4495e-02  5.4072e-01         0.5887\nHuitong        2.5997e-01 -5.2447e-03  1.1077e-01  7.9685e-01         0.4255\nJiahe         -1.2431e-01 -3.0550e-03  5.1111e-02 -5.3633e-01         0.5917\nJianghua       2.8651e-01 -3.8280e-03  8.0968e-02  1.0204e+00         0.3076\nJiangyong      2.4337e-01 -2.7082e-03  1.1746e-01  7.1800e-01         0.4728\nJingzhou       1.8270e-01 -8.5106e-04  2.4363e-02  1.1759e+00         0.2396\nJinshi        -1.1988e-02 -5.3666e-03  1.1334e-01 -1.9667e-02         0.9843\nJishou        -2.8680e-01 -2.6305e-03  4.4028e-02 -1.3543e+00         0.1756\nLanshan        6.3334e-02 -9.6365e-04  2.0441e-02  4.4972e-01         0.6529\nLeiyang        1.1581e-02 -1.4948e-04  2.5082e-03  2.3422e-01         0.8148\nLengshuijiang -1.7903e+00 -8.2129e-02  2.1598e+00 -1.1623e+00         0.2451\nLi             1.0225e-03 -2.4048e-07  5.1060e-06  4.5260e-01         0.6508\nLianyuan      -1.4672e-01 -1.8983e-03  1.9145e-02 -1.0467e+00         0.2952\nLiling         1.3774e+00 -1.5097e-02  4.2601e-01  2.1335e+00         0.0329\nLinli          1.4815e-02 -6.8294e-05  1.4499e-03  3.9086e-01         0.6959\nLinwu         -2.4621e-03 -9.0703e-06  1.9258e-04 -1.7676e-01         0.8597\nLinxiang       6.5904e-02 -2.9028e-03  2.5470e-01  1.3634e-01         0.8916\nLiuyang        3.3688e+00 -7.7502e-02  1.5180e+00  2.7972e+00         0.0052\nLonghui        8.0801e-01 -1.1377e-02  1.5538e-01  2.0787e+00         0.0376\nLongshan       7.5663e-01 -1.1100e-02  3.1449e-01  1.3690e+00         0.1710\nLuxi           1.8177e-01 -2.4855e-03  3.4249e-02  9.9561e-01         0.3194\nMayang         2.1852e-01 -5.8773e-03  9.8049e-02  7.1663e-01         0.4736\nMiluo          1.8704e+00 -1.6927e-02  2.7925e-01  3.5715e+00         0.0004\nNan           -9.5789e-03 -4.9497e-04  6.8341e-03 -1.0988e-01         0.9125\nNingxiang      1.5607e+00 -7.3878e-02  8.0012e-01  1.8274e+00         0.0676\nNingyuan       2.0910e-01 -7.0884e-03  8.2306e-02  7.5356e-01         0.4511\nPingjiang     -9.8964e-01 -2.6457e-03  5.6027e-02 -4.1698e+00         0.0000\nQidong         1.1806e-01 -2.1207e-03  2.4747e-02  7.6396e-01         0.4449\nQiyang         6.1966e-02 -7.3374e-04  8.5743e-03  6.7712e-01         0.4983\nRucheng       -3.6992e-01 -8.8999e-03  2.5272e-01 -7.1814e-01         0.4727\nSangzhi        2.5053e-01 -4.9470e-03  6.8000e-02  9.7972e-01         0.3272\nShaodong      -3.2659e-02 -3.6592e-05  5.0546e-04 -1.4510e+00         0.1468\nShaoshan       2.1223e+00 -5.0227e-02  1.3668e+00  1.8583e+00         0.0631\nShaoyang       5.9499e-01 -1.1253e-02  1.3012e-01  1.6807e+00         0.0928\nShimen        -3.8794e-02 -3.8603e-04  6.4756e-03 -4.7729e-01         0.6332\nShuangfeng     9.2835e-03 -2.2867e-03  3.1516e-02  6.5174e-02         0.9480\nShuangpai      8.0591e-02 -3.1366e-04  8.9838e-03  8.5358e-01         0.3933\nSuining        3.7585e-01 -3.5933e-03  4.1870e-02  1.8544e+00         0.0637\nTaojiang      -2.5394e-01 -1.2395e-03  1.4477e-02 -2.1002e+00         0.0357\nTaoyuan        1.4729e-02 -1.2039e-04  8.5103e-04  5.0903e-01         0.6107\nTongdao        4.6482e-01 -6.9870e-03  1.9879e-01  1.0582e+00         0.2900\nWangcheng      4.4220e+00 -1.1067e-01  1.3596e+00  3.8873e+00         0.0001\nWugang         7.1003e-01 -7.8144e-03  1.0710e-01  2.1935e+00         0.0283\nXiangtan       2.4530e-01 -3.6457e-04  3.2319e-03  4.3213e+00         0.0000\nXiangxiang     2.6271e-01 -1.2703e-03  2.1290e-02  1.8092e+00         0.0704\nXiangyin       5.4525e-01 -4.7442e-03  7.9236e-02  1.9539e+00         0.0507\nXinhua         1.1810e-01 -6.2649e-03  8.6001e-02  4.2409e-01         0.6715\nXinhuang       1.5725e-01 -4.1820e-03  3.6648e-01  2.6667e-01         0.7897\nXinning        6.8928e-01 -9.6674e-03  2.0328e-01  1.5502e+00         0.1211\nXinshao        5.7578e-02 -8.5932e-03  1.1769e-01  1.9289e-01         0.8470\nXintian       -7.4050e-03 -5.1493e-03  1.0877e-01 -6.8395e-03         0.9945\nXupu           3.2406e-01 -5.7468e-03  5.7735e-02  1.3726e+00         0.1699\nYanling       -6.9021e-02 -5.9211e-04  9.9306e-03 -6.8667e-01         0.4923\nYizhang       -2.6844e-01 -2.2463e-03  4.7588e-02 -1.2202e+00         0.2224\nYongshun       6.3064e-01 -1.1350e-02  1.8830e-01  1.4795e+00         0.1390\nYongxing       4.3411e-01 -9.0735e-03  1.5088e-01  1.1409e+00         0.2539\nYou            7.8750e-02 -7.2728e-03  1.2116e-01  2.4714e-01         0.8048\nYuanjiang      2.0004e-04 -1.7760e-04  2.9798e-03  6.9181e-03         0.9945\nYuanling       8.7298e-03 -2.2981e-06  2.3221e-05  1.8121e+00         0.0700\nYueyang        4.1189e-02 -1.9768e-04  2.3113e-03  8.6085e-01         0.3893\nZhijiang       1.0476e-01 -7.8123e-04  1.3100e-02  9.2214e-01         0.3565\nZhongfang     -2.2685e-01 -2.1455e-03  3.5927e-02 -1.1855e+00         0.2358\nZhuzhou        3.2864e-01 -5.2432e-04  7.2391e-03  3.8688e+00         0.0001\nZixing        -7.6849e-01 -8.8210e-02  9.4057e-01 -7.0144e-01         0.4830\n```\n:::\n:::\n\n\n#### 10.6.1.1 Mapping the local Moran's I\n\nBefore mapping the local Moran's I map, it is wise to append the local Moran's I dataframe (i.e. localMI) onto hunan SpatialPolygonDataFrame. The code chunks below can be used to perform the task. The out SpatialPolygonDataFrame is called *hunan.localMI*.\n\nThe `Pr.z….E.Ii..` containing p-value of the local moran I is renamed to `PR.Ii`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan.localMI <- cbind(hunan,localMI) %>% \n    rename(Pr.Ii = Pr.z....E.Ii..)\n```\n:::\n\n\n#### 10.6.1.2 Mapping local Moran's I values\n\nUsing choropleth mapping functions of **tmap** package, we can plot the local Moran's I values by using the code chunks below. For paletter colours, refer to colorbrewers [link](https://r-graph-gallery.com/38-rcolorbrewers-palettes.html).\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\ntm_shape(hunan.localMI) +\n  tm_fill(col='Ii',\n          style = 'pretty',\n          #palette = 'RdBu', # << refer to colourbrewer\n          title = 'Local Moran statistics') +\n  tm_borders(alpha= 0.5) + \n  tm_layout(main.title = \"Local Moran's I\",\n            legend.width= 0.25,\n            legend.height = 0.25)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-32-1.png){width=1344}\n:::\n:::\n\n\n#### 10.6.1.3 Mapping local Moran's I p-values\n\nThe choropleth shows there is evidence for both positive and negative Ii values. However, it is useful to **consider the p-values** for each of these values, as consider above.\n\nThe code chunks below produce a choropleth map of Moran's I p-values by using functions of **tmap** package.\n\n::: panel-tabset\n## Various p values\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Local Moran's I p-values\",\n            legend.width= 0.25,\n            legend.height = 0.25)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-33-1.png){width=1344}\n:::\n:::\n\n\n## p values at 95% confidence level\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks = c(-Inf, 0.05, Inf),\n          palette = c('lightblue', 'grey'), \n          title = \"Local Moran's I p-values\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Significant Local Moran's I \\np-values at 95% Confidence level\",\n            main.title.size = 1,\n            legend.width = 0.25,\n            legend.height = 0.25)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-34-1.png){width=1344}\n:::\n:::\n\n:::\n\n#### 10.6.1.4 Mapping both local Moran's I values and p-values\n\nFor effective interpretation, it is better to plot both the local Moran's I values map and its corresponding p-values map next to each other.\n\nThe code chunk below will be used to create such visualisation.\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nlocalMI.map <- tm_shape(hunan.localMI) +\n  tm_fill(col='Ii',\n          style = 'pretty',\n          #palette = 'RdBu', # << reger to colourbrewer\n          title = 'Local Moran statistics') +\n  tm_borders(alpha= 0.5) + \n  tm_layout(main.title = \"Local Moran's I\",\n            legend.width= 0.25,\n            legend.height = 0.25)\n\npvalue.map <-tm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks = c(-Inf, 0.05, Inf),\n          palette = c('lightblue', 'grey'), \n          title = \"Local Moran's I p-values\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Significant Local Moran's I \\np-values at 95% Confidence level\",\n            main.title.size = 1,\n            legend.width = 0.25,\n            legend.height = 0.25)\n\ntmap_arrange(localMI.map, pvalue.map, asp=1,ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-35-1.png){width=1344}\n:::\n:::\n\n\n> For the choropleth chart on the left, dark green represents clustering of similar values (HH or LL, to be determine by Moran scatterplot or LISAmap) while orange represents outlier regions (LH or HL). THe chart on the right would show us the significant clusters or outliers.\n\n## **10.7 Creating a LISA Cluster Map**\n\nThe LISA Cluster Map shows the **significant** locations color coded by type of spatial autocorrelation. The first step before we can generate the LISA cluster map is to plot the **Moran scatterplot**.\n\n### **10.7.1 Plotting Moran scatterplot**\n\nThe Moran scatterplot is an illustration of the **relationship** between the values of the **chosen attribute at each location** and the **average value of the same attribute at neighboring locations.**\n\nThe code chunk below plots the Moran scatterplot of GDPPC 2012 by using [*moran.plot()*](https://r-spatial.github.io/spdep/reference/moran.plot.html) of **spdep**.\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nnci <- moran.plot(hunan$GDPPC,\n                  listw = rswm_q,\n                  labels = as.character(hunan$County),\n                  xlab = 'GDPPC 2012',\n                  ylab = 'Spatially lag GDPPC 2012')\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-36-1.png){width=1344}\n:::\n:::\n\n\n> The x -axis shows the original variable value at a particular spatial unit and the y-axis is the (weighted or without) average of the neighbouring variable values. The neighbour definition and relationship is embedded in the 'listw' argument where it could be\n>\n> -   spatial lag with row-standardised weights\n>\n> -   spatial lag as sum of neighbours values (binary)\n>\n> -   spatial window average (self-included)\n>\n> -   spatial window sum (self-included and binary)\n>\n> -   inverse-distance\n>\n> Notice that the plot is split in 4 quadrants.\n>\n> -   Clusters and + spatial autocorrelation: The top right corner belongs to areas that have high GDPPC and are surrounded by other areas that have the average level of GDPPC. This are the high-high locations in the lesson slide.\n>\n> -   Cluster and + spatial autocorrelation: Bottom left are the Low-low.\n>\n> -   Outlier and - spatial autocorrelation: Top left contains spatial units with low GDPPC and surrounded by higher values.\n>\n> -   Outlier and - spatial autocorrelation: Bottom right contains spatial units with higher GDPPC and surrounded by relatively lower values.\n\n### **10.7.2 Plotting Moran scatterplot with standardised variable**\n\nFirst we will use [*scale()*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/scale) to centers and scales the variable. Here centering is done by [subtracting the mean]{.underline} (omitting NAs) the corresponding columns, and scaling is done by dividing the (centered) variable by their [standard deviations]{.underline}.\n\n**`hunan$GDPPC`** will have a **mean of 0** and a **standard deviation of 1**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan$Z.GDPPC <- scale(hunan$GDPPC) %>% \n  as.vector \n```\n:::\n\n\nThe [*as.vector()*](https://www.rdocumentation.org/packages/pbdDMAT/versions/0.5-1/topics/as.vector) added to the end is to make sure that the data type we get out of this is a vector, that map neatly into our `hunan` dataframe\n\nWithout setting as vector, scale(hunan\\$GDPPC) is a matrix array.\n\nNow, plot the Moran scatterplot again by using the code chunk below.\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nnci2 <- moran.plot(hunan$Z.GDPPC,\n                  listw = rswm_q,\n                  labels = as.character(hunan$County),\n                  xlab = 'GDPPC 2012',\n                  ylab = 'Spatially lag z-GDPPC 2012')\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-38-1.png){width=1344}\n:::\n:::\n\n\n> We notice that both axes are standardised with mean =0 and sd of 1.\n\n**10.7.3 Preparing LISA map classes**\n\nThe code chunks below show the steps to prepare a LISA cluster map.\n\n1.  The code initializes a numeric vector named **`quadrant`** with a length equal to the number of rows in the **`localMI`** data frame. The vector is initially filled with **`NA.`**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquadrant <- vector(mode=\"numeric\",length=nrow(localMI))\n```\n:::\n\n\nNext, derive the spatially lagged variable of interest (i.e. GDPPC) using `lag.listw()` from the *spdep* package and centers the spatially lagged variable around its mean via subtraction.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan$lag_GDPPC <- lag.listw(rswm_q, hunan$GDPPC)\nDV <- hunan$lag_GDPPC - mean(hunan$lag_GDPPC)     \nclass(DV)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\nRetrieve the first column (li aka Moran's I values) from the `localMI` matrix and centered around its mean via subtraction.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#colnames(localMI)\nLM_I <- localMI[,1] - mean(localMI[,1])\nclass(LM_I)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\nNext, we will set a statistical significance level for the local Moran.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsignif <- 0.05\n```\n:::\n\n\nThese four command lines define the (1) low-low, (2) low-high , (3) high-low and (4) high-high categories. Comparing the local Moran's I values with its lag-variable values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquadrant[DV <0 & LM_I>0] <- 1 # LL\nquadrant[DV >0 & LM_I<0] <- 2 # LH\nquadrant[DV <0 & LM_I<0] <- 3 # HL\nquadrant[DV >0 & LM_I>0] <- 4 # HH\n```\n:::\n\n\n> LM_I \\> 0 : cluster of **similar** values.\n>\n> **(1)** When DV \\< 0 and LM_I \\> 0, low values of spatial **lag** variables cluster together with low non-lag variable. Thus Low-low.\n>\n> **(4)** When DV \\> 0 and LM_I \\> 0, high values of spatial **lag** variables cluster together with high non-lag variable. Thus high-high.\n>\n> LM_I \\<0 : cluster of **dissimilar** values.\n>\n> **(2)** When DV \\> 0 and LM \\< 0, high values of spatial lag variables are among low non-lag variable, thus low-high. (see moran scatterplot's Y axis)\n>\n> **(3**) When DV \\< 0 and LM_I \\< 0 , low values of spatial lag variables are among the high non-lag variable, thus high-low.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquadrant\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 2 3 3 2 2 3 4 4 4 2 2 3 2 2 2 4 3 3 2 3 3 2 3 3 3 3 3 3 1 3 1 3 3 3 3 3 1 3\n[39] 1 1 3 1 1 1 3 4 2 1 3 3 3 3 1 3 1 2 2 2 3 3 3 3 2 3 2 4 2 4 3 3 4 2 2 4 3 2\n[77] 3 2 1 2 3 3 2 4 3 2 3 3\n```\n:::\n:::\n\n\nLastly, places non-significant Moran in the category 0. The fifth column of the `localMI` matrix is the significant value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquadrant[localMI[,5]>signif] <- 0\nquadrant\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0 0 0 0 0 0 4 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[39] 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 2 0 0 0 4 0 0 4 0 0\n[77] 0 2 0 0 0 0 0 4 0 2 0 0\n```\n:::\n:::\n\n\nCombining all the steps above into one code chunk:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquadrant <- vector(mode=\"numeric\",length=nrow(localMI))\nhunan$lag_GDPPC <- lag.listw(rswm_q, hunan$GDPPC)\nDV <- hunan$lag_GDPPC - mean(hunan$lag_GDPPC)     \nLM_I <- localMI[,1]   \nsignif <- 0.05       \nquadrant[DV <0 & LM_I>0] <- 1 # LL\nquadrant[DV >0 & LM_I<0] <- 2 # LH\nquadrant[DV <0 & LM_I<0] <- 3 # HL\nquadrant[DV >0 & LM_I>0] <- 4 # HH\nquadrant[localMI[,5]>signif] <- 0 # non-sig\n```\n:::\n\n\n### **10.7.4 Plotting LISA map**\n\nNow, we can build the LISA map by using the code chunks below.\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nhunan.localMI$quadrant <- quadrant\ncolors <- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\n\nLISAmap <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], #index starts from 1\n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_text('County',\n          size = 0.5)+\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5) +\n  tm_layout(main.title='LISA map (significant)',\n            legend.width = 0.25,\n            legend.height = 0.25)\n\nLISAmap\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-47-1.png){width=1344}\n:::\n:::\n\n\nFor effective interpretation, it is better to plot both the **local Moran's I values map** and its corresponding LISA map next to each other.\n\nThe code chunk below will be used to create such visualisation.\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\ntmap_arrange(localMI.map, LISAmap,\n             asp=1,\n             ncol=2 )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-48-1.png){width=1344}\n:::\n:::\n\n\n> 'Clustering of dissimilar values' (Local Moran I \\< 0) is also known as 'dispersion' or 'outlier' region.\n>\n> The darker green regions shows signs of clustering of similar values while the orange regions shows signs of dispersion (cluster of dissimilar values). The LISA map on the right will be able to give more detailed insights, for e.g. for cluster regions whether is it HH or LL and for the outliers region whether its LH or HL.\n\nThe GDPPC and LISA Map can also be placed side by side .\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\ngdppc <- qtm(hunan, 'GDPPC') +\n  tm_layout(main.title= 'GDPPC')\n\ntmap_arrange(gdppc, LISAmap,\n             asp=1,\n             ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-49-1.png){width=1344}\n:::\n:::\n\n\n> LISAmap:\n>\n> The dark blue and red regions are clusters of LL and HH respectively.\n>\n> The light blue regions are outliers (LH), where those regions have relatively lower values than their neighbours.\n\n## **10.8 Hot Spot and Cold Spot Area Analysis**\n\nBeside detecting cluster and outliers, localised spatial statistics can be also used to detect hot spot (high values amongst high) and/or cold spot areas (low values amongst low).\n\nThe term 'hot spot' has been used generically across disciplines to describe a region or value that is higher relative to its surroundings (Lepers et al 2005, Aben et al 2012, Isobe et al 2015).\n\n### **10.8.1 Getis and Ord's G-Statistics**\n\nAn alternative spatial statistics to detect spatial anomalies is the Getis and Ord's G-statistics (Getis and Ord, 1972; Ord and Getis, 1995). It looks at neighbours within a **defined proximity (use of distance)** to identify where either high or low values cluster spatially. Here, statistically significant hot-spots are recognised as areas of high values where other areas within a neighbourhood range also share high values too.\n\nThe analysis consists of three steps:\n\n-   Deriving spatial weight matrix\n\n-   Computing Gi statistics\n\n-   Mapping Gi statistics\n\n### **10.8.2 Deriving distance-based weight matrix**\n\nFirst, we need to define a new set of neighbours. Whist the spatial autocorrelation considered units which shared borders, for Getis-Ord we are defining **neighbours based on distance. The spatial weights matrix used in this section is binary.**\n\nThere are two type of distance-based proximity matrix, they are:\n\n-   fixed distance weight matrix; and\n\n-   adaptive distance weight matrix.\n\nFrom Hands-on_Ex2.1:\n\n![](images/Summary%20of%20deriving%20weights%20matrix-01.png)\n\n#### 10.8.2.1 Deriving the centroid\n\nWe will need points to associate with each polygon before we can make our connectivity graph. It will be a little more complicated than just running *st_centroid()* on the sf object: **us.bound**. We need the coordinates in a separate data frame for this to work. To do this we will use a mapping function. The mapping function applies a given function to each element of a vector and returns a vector of the same length. Our input vector will be the geometry column of us.bound. Our function will be *st_centroid()*. We will be using map_dbl variation of map from the purrr package. For more documentation, check out map documentation\n\nTo get our longitude values we map the *st_centroid()* function over the geometry column of us.bound and access the longitude value through double bracket notation \\[\\[\\]\\] and 1. This allows us to get only the longitude, which is the first value in each centroid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n```\n:::\n\n\nThe latitude can be accessed using \\[\\[2\\]\\]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n```\n:::\n\n\nWith both long and lat, we use cbind to put longitude and latitude into the same object. The object `coords` represents the CG of all 88 spatial units/ features/ polygons.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- cbind(longitude, latitude)\nhead(coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n```\n:::\n:::\n\n\n#### 10.8.2.2 Determine the cut-off distance\n\nFirstly, we need to determine the upper limit for distance band by using the steps below:\n\n-   Return a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using [*knearneigh()*](https://r-spatial.github.io/spdep/reference/knearneigh.html) of **spdep**. (k=1)\n\n-   Convert the knn object returned by *knearneigh()* into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using [*knn2nb()*](https://r-spatial.github.io/spdep/reference/knn2nb.html).\n\n-   Return the **length** (distance) of neighbour relationship edges by using [*nbdists()*](https://r-spatial.github.io/spdep/reference/nbdists.html) of **spdep**. The function returns in the units of the coordinates if the coordinates are projected, in **km** otherwise.\n\n-   Remove the list structure of the returned object by using [**unlist()**](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/unlist). The purpose of doing so it to run the summary() function on it in order for us to decide on a distance threshold. Decide on a distance threshold value such that each spatial unit has at least a neighbour.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#coords <- coordinates(hunan)\nk1 <- knn2nb(knearneigh(coords))\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n```\n:::\n:::\n\n\nThe summary report shows that the largest first nearest neighbour distance is 61.79 km, so using this as the upper threshold gives certainty that all units will have at least one neighbour. The threshold chosen is 62 km.\n\n#### 10.8.2.3 Computing fixed distance weight matrix\n\nNow, we will compute the 'nb' class by using [*dnearneigh()*](https://r-spatial.github.io/spdep/reference/dnearneigh.html) as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)\nsummary(wm_d62)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \nLink number distribution:\n\n 1  2  3  4  5  6 \n 6 15 14 26 20  7 \n6 least connected regions:\n6 15 30 32 56 65 with 1 link\n7 most connected regions:\n21 28 35 45 50 52 82 with 6 links\n```\n:::\n:::\n\n\nSneak peak into neighbours lists of first 3 polygons\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_d62[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1]  3  4  5 57 64\n\n[[2]]\n[1] 57 58 78 85\n\n[[3]]\n[1]  1  4  5 57\n```\n:::\n:::\n\n\nNext, *nb2listw()* is used to convert the nb object into spatial weights matrix object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm62_lw <- nb2listw(wm_d62, style = 'B')\nsummary(wm62_lw)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \nLink number distribution:\n\n 1  2  3  4  5  6 \n 6 15 14 26 20  7 \n6 least connected regions:\n6 15 30 32 56 65 with 1 link\n7 most connected regions:\n21 28 35 45 50 52 82 with 6 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1   S2\nB 88 7744 324 648 5440\n```\n:::\n:::\n\n\nSneak peak of `wm62_lw` spatial weights matrix (binary). The class is 'listw' and 'nb'.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm62_lw$weights[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 1 1 1 1\n\n[[2]]\n[1] 1 1 1 1\n\n[[3]]\n[1] 1 1 1 1\n```\n:::\n:::\n\n\n### **10.8.3 Computing adaptive distance weight matrix (Fixed \\# of nb)**\n\nOne of the characteristics of fixed distance weight matrix is that more densely settled areas (usually the urban areas) tend to have more neighbours and the less densely settled areas (usually the rural counties) tend to have lesser neighbours. Having many neighbours smoothes the neighbour relationship across more neighbours.\n\nIt is possible to control the numbers of neighbours directly using k-nearest neighbours, either accepting asymmetric neighbours or imposing symmetry as shown in the code chunk below.\n\n`knn` is a nb object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknn <- knn2nb(knearneigh(coords, k=8))\nknn\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\n```\n:::\n:::\n\n\nSneak peak into the neighbour structure/list of `knn.`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknn[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1]  2  3  4  5 57 58 64 85\n\n[[2]]\n[1]  1  3  5 57 58 68 78 85\n\n[[3]]\n[1]  1  2  4  5 57 58 64 85\n```\n:::\n:::\n\n\n> Each spatial unit has exactly 8 neighbours.\n\nNext, *nb2listw()* is used to convert the nb object into spatial weights object, `knn_lw`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknn_lw <- nb2listw(knn, style = 'B')\nsummary(knn_lw)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\nLink number distribution:\n\n 8 \n88 \n88 least connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n88 most connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0   S1    S2\nB 88 7744 704 1300 23014\n```\n:::\n:::\n\n\nSneak peak into the weights of `knn_lw` spatial weights matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknn_lw$weights[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 1 1 1 1 1 1 1\n\n[[2]]\n[1] 1 1 1 1 1 1 1 1\n\n[[3]]\n[1] 1 1 1 1 1 1 1 1\n```\n:::\n\n```{.r .cell-code}\n# attributes(knn_lw)\n```\n:::\n\n\n## **10.9 Computing Gi statistics**\n\n### **10.9.1 Gi statistics using fixed distance**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfips <- order(hunan$County)\ngi.fixed <- localG(hunan$GDPPC, wm62_lw)\ngi.fixed\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  0.436075843 -0.265505650 -0.073033665  0.413017033  0.273070579\n [6] -0.377510776  2.863898821  2.794350420  5.216125401  0.228236603\n[11]  0.951035346 -0.536334231  0.176761556  1.195564020 -0.033020610\n[16]  1.378081093 -0.585756761 -0.419680565  0.258805141  0.012056111\n[21] -0.145716531 -0.027158687 -0.318615290 -0.748946051 -0.961700582\n[26] -0.796851342 -1.033949773 -0.460979158 -0.885240161 -0.266671512\n[31] -0.886168613 -0.855476971 -0.922143185 -1.162328599  0.735582222\n[36] -0.003358489 -0.967459309 -1.259299080 -1.452256513 -1.540671121\n[41] -1.395011407 -1.681505286 -1.314110709 -0.767944457 -0.192889342\n[46]  2.720804542  1.809191360 -1.218469473 -0.511984469 -0.834546363\n[51] -0.908179070 -1.541081516 -1.192199867 -1.075080164 -1.631075961\n[56] -0.743472246  0.418842387  0.832943753 -0.710289083 -0.449718820\n[61] -0.493238743 -1.083386776  0.042979051  0.008596093  0.136337469\n[66]  2.203411744  2.690329952  4.453703219 -0.340842743 -0.129318589\n[71]  0.737806634 -1.246912658  0.666667559  1.088613505 -0.985792573\n[76]  1.233609606 -0.487196415  1.626174042 -1.060416797  0.425361422\n[81] -0.837897118 -0.314565243  0.371456331  4.424392623 -0.109566928\n[86]  1.364597995 -1.029658605 -0.718000620\nattr(,\"internals\")\n               Gi      E(Gi)        V(Gi)        Z(Gi) Pr(z != E(Gi))\n [1,] 0.064192949 0.05747126 2.375922e-04  0.436075843   6.627817e-01\n [2,] 0.042300020 0.04597701 1.917951e-04 -0.265505650   7.906200e-01\n [3,] 0.044961480 0.04597701 1.933486e-04 -0.073033665   9.417793e-01\n [4,] 0.039475779 0.03448276 1.461473e-04  0.413017033   6.795941e-01\n [5,] 0.049767939 0.04597701 1.927263e-04  0.273070579   7.847990e-01\n [6,] 0.008825335 0.01149425 4.998177e-05 -0.377510776   7.057941e-01\n [7,] 0.050807266 0.02298851 9.435398e-05  2.863898821   4.184617e-03\n [8,] 0.083966739 0.04597701 1.848292e-04  2.794350420   5.200409e-03\n [9,] 0.115751554 0.04597701 1.789361e-04  5.216125401   1.827045e-07\n[10,] 0.049115587 0.04597701 1.891013e-04  0.228236603   8.194623e-01\n[11,] 0.045819180 0.03448276 1.420884e-04  0.951035346   3.415864e-01\n[12,] 0.049183846 0.05747126 2.387633e-04 -0.536334231   5.917276e-01\n[13,] 0.048429181 0.04597701 1.924532e-04  0.176761556   8.596957e-01\n[14,] 0.034733752 0.02298851 9.651140e-05  1.195564020   2.318667e-01\n[15,] 0.011262043 0.01149425 4.945294e-05 -0.033020610   9.736582e-01\n[16,] 0.065131196 0.04597701 1.931870e-04  1.378081093   1.681783e-01\n[17,] 0.027587075 0.03448276 1.385862e-04 -0.585756761   5.580390e-01\n[18,] 0.029409313 0.03448276 1.461397e-04 -0.419680565   6.747188e-01\n[19,] 0.061466754 0.05747126 2.383385e-04  0.258805141   7.957856e-01\n[20,] 0.057656917 0.05747126 2.371303e-04  0.012056111   9.903808e-01\n[21,] 0.066518379 0.06896552 2.820326e-04 -0.145716531   8.841452e-01\n[22,] 0.045599896 0.04597701 1.928108e-04 -0.027158687   9.783332e-01\n[23,] 0.030646753 0.03448276 1.449523e-04 -0.318615290   7.500183e-01\n[24,] 0.035635552 0.04597701 1.906613e-04 -0.748946051   4.538897e-01\n[25,] 0.032606647 0.04597701 1.932888e-04 -0.961700582   3.362000e-01\n[26,] 0.035001352 0.04597701 1.897172e-04 -0.796851342   4.255374e-01\n[27,] 0.012746354 0.02298851 9.812587e-05 -1.033949773   3.011596e-01\n[28,] 0.061287917 0.06896552 2.773884e-04 -0.460979158   6.448136e-01\n[29,] 0.014277403 0.02298851 9.683314e-05 -0.885240161   3.760271e-01\n[30,] 0.009622875 0.01149425 4.924586e-05 -0.266671512   7.897221e-01\n[31,] 0.014258398 0.02298851 9.705244e-05 -0.886168613   3.755267e-01\n[32,] 0.005453443 0.01149425 4.986245e-05 -0.855476971   3.922871e-01\n[33,] 0.043283712 0.05747126 2.367109e-04 -0.922143185   3.564539e-01\n[34,] 0.020763514 0.03448276 1.393165e-04 -1.162328599   2.451020e-01\n[35,] 0.081261843 0.06896552 2.794398e-04  0.735582222   4.619850e-01\n[36,] 0.057419907 0.05747126 2.338437e-04 -0.003358489   9.973203e-01\n[37,] 0.013497133 0.02298851 9.624821e-05 -0.967459309   3.333145e-01\n[38,] 0.019289310 0.03448276 1.455643e-04 -1.259299080   2.079223e-01\n[39,] 0.025996272 0.04597701 1.892938e-04 -1.452256513   1.464303e-01\n[40,] 0.016092694 0.03448276 1.424776e-04 -1.540671121   1.233968e-01\n[41,] 0.035952614 0.05747126 2.379439e-04 -1.395011407   1.630124e-01\n[42,] 0.031690963 0.05747126 2.350604e-04 -1.681505286   9.266481e-02\n[43,] 0.018750079 0.03448276 1.433314e-04 -1.314110709   1.888090e-01\n[44,] 0.015449080 0.02298851 9.638666e-05 -0.767944457   4.425202e-01\n[45,] 0.065760689 0.06896552 2.760533e-04 -0.192889342   8.470456e-01\n[46,] 0.098966900 0.05747126 2.326002e-04  2.720804542   6.512325e-03\n[47,] 0.085415780 0.05747126 2.385746e-04  1.809191360   7.042128e-02\n[48,] 0.038816536 0.05747126 2.343951e-04 -1.218469473   2.230456e-01\n[49,] 0.038931873 0.04597701 1.893501e-04 -0.511984469   6.086619e-01\n[50,] 0.055098610 0.06896552 2.760948e-04 -0.834546363   4.039732e-01\n[51,] 0.033405005 0.04597701 1.916312e-04 -0.908179070   3.637836e-01\n[52,] 0.043040784 0.06896552 2.829941e-04 -1.541081516   1.232969e-01\n[53,] 0.011297699 0.02298851 9.615920e-05 -1.192199867   2.331829e-01\n[54,] 0.040968457 0.05747126 2.356318e-04 -1.075080164   2.823388e-01\n[55,] 0.023629663 0.04597701 1.877170e-04 -1.631075961   1.028743e-01\n[56,] 0.006281129 0.01149425 4.916619e-05 -0.743472246   4.571958e-01\n[57,] 0.063918654 0.05747126 2.369553e-04  0.418842387   6.753313e-01\n[58,] 0.070325003 0.05747126 2.381374e-04  0.832943753   4.048765e-01\n[59,] 0.025947288 0.03448276 1.444058e-04 -0.710289083   4.775249e-01\n[60,] 0.039752578 0.04597701 1.915656e-04 -0.449718820   6.529132e-01\n[61,] 0.049934283 0.05747126 2.334965e-04 -0.493238743   6.218439e-01\n[62,] 0.030964195 0.04597701 1.920248e-04 -1.083386776   2.786368e-01\n[63,] 0.058129184 0.05747126 2.343319e-04  0.042979051   9.657182e-01\n[64,] 0.046096514 0.04597701 1.932637e-04  0.008596093   9.931414e-01\n[65,] 0.012459080 0.01149425 5.008051e-05  0.136337469   8.915545e-01\n[66,] 0.091447733 0.05747126 2.377744e-04  2.203411744   2.756574e-02\n[67,] 0.049575872 0.02298851 9.766513e-05  2.690329952   7.138140e-03\n[68,] 0.107907212 0.04597701 1.933581e-04  4.453703219   8.440175e-06\n[69,] 0.019616151 0.02298851 9.789454e-05 -0.340842743   7.332220e-01\n[70,] 0.032923393 0.03448276 1.454032e-04 -0.129318589   8.971056e-01\n[71,] 0.030317663 0.02298851 9.867859e-05  0.737806634   4.606320e-01\n[72,] 0.019437582 0.03448276 1.455870e-04 -1.246912658   2.124295e-01\n[73,] 0.055245460 0.04597701 1.932838e-04  0.666667559   5.049845e-01\n[74,] 0.074278054 0.05747126 2.383538e-04  1.088613505   2.763244e-01\n[75,] 0.013269580 0.02298851 9.719982e-05 -0.985792573   3.242349e-01\n[76,] 0.049407829 0.03448276 1.463785e-04  1.233609606   2.173484e-01\n[77,] 0.028605749 0.03448276 1.455139e-04 -0.487196415   6.261191e-01\n[78,] 0.039087662 0.02298851 9.801040e-05  1.626174042   1.039126e-01\n[79,] 0.031447120 0.04597701 1.877464e-04 -1.060416797   2.889550e-01\n[80,] 0.064005294 0.05747126 2.359641e-04  0.425361422   6.705732e-01\n[81,] 0.044606529 0.05747126 2.357330e-04 -0.837897118   4.020885e-01\n[82,] 0.063700493 0.06896552 2.801427e-04 -0.314565243   7.530918e-01\n[83,] 0.051142205 0.04597701 1.933560e-04  0.371456331   7.102977e-01\n[84,] 0.102121112 0.04597701 1.610278e-04  4.424392623   9.671399e-06\n[85,] 0.021901462 0.02298851 9.843172e-05 -0.109566928   9.127528e-01\n[86,] 0.064931813 0.04597701 1.929430e-04  1.364597995   1.723794e-01\n[87,] 0.031747344 0.04597701 1.909867e-04 -1.029658605   3.031703e-01\n[88,] 0.015893319 0.02298851 9.765131e-05 -0.718000620   4.727569e-01\nattr(,\"cluster\")\n [1] Low  Low  High High High High High High High Low  Low  High Low  Low  Low \n[16] High High High High Low  High High Low  Low  High Low  Low  Low  Low  Low \n[31] Low  Low  Low  High Low  Low  Low  Low  Low  Low  High Low  Low  Low  Low \n[46] High High Low  Low  Low  Low  High Low  Low  Low  Low  Low  High Low  Low \n[61] Low  Low  Low  High High High Low  High Low  Low  High Low  High High Low \n[76] High Low  Low  Low  Low  Low  Low  High High Low  High Low  Low \nLevels: Low High\nattr(,\"gstari\")\n[1] FALSE\nattr(,\"call\")\nlocalG(x = hunan$GDPPC, listw = wm62_lw)\nattr(,\"class\")\n[1] \"localG\"\n```\n:::\n\n```{.r .cell-code}\n#attributes(gi.fixed)\n```\n:::\n\n\nThe output of localG() is a vector of G or Gstar values, with attributes \"gstari\" set to FALSE (as default), \"call\" set to the function call, and class \"localG\".\n\nThe Gi statistics is represented as a **Z-score.** Greater values represent a greater intensity of clustering and the direction (positive or negative) indicates high or low clusters.\n\nNext, we will join the Gi values to their corresponding hunan sf data frame by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan.gi <- cbind(hunan, as.matrix(gi.fixed)) %>%\n  rename(gstat_fixed = as.matrix.gi.fixed.)\n```\n:::\n\n\nThe code chunk above performs three tasks. First, it converts the output vector (i.e. *gi.fixed*) into r matrix object by using *as.matrix()*. Next, *cbind()* is used to join hunan\\@data and *gi.fixed* matrix to produce a new SpatialPolygonDataFrame called *hunan.gi*. Lastly, the field name of the gi values is renamed to *gstat_fixed* by using *rename()*.\n\n### **10.9.2 Mapping Gi values with fixed distance weights**\n\nThe code chunk below shows the functions used to map the Gi values derived using fixed distance weight matrix.\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\ngdppc <- qtm(hunan, \"GDPPC\") +\n    tm_layout(main.title= 'GDPPC')\n\nGimap <-tm_shape(hunan.gi) +\n  tm_fill(col = \"gstat_fixed\", \n          style = \"pretty\",\n          palette=\"-RdBu\",\n          title = \"local Gi\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title= 'local Gi (fixed-dist)')\n\ntmap_arrange(gdppc, Gimap, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-64-1.png){width=1344}\n:::\n:::\n\n\n> Chart on the right has Red regions (hotspots with high values clustering together) and Blue regions (Coldspots with low values clustering together).\n\nBut we are not sure of the hot/cold spots are statistically significant. We should extract the p-values in order to know.\n\n#### **10.9.2.1 Including significant Gi values**\n\nExamine the structure of `gi.fixed`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(gi.fixed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n 'localG' num [1:88] 0.436 -0.266 -0.073 0.413 0.273 ...\n - attr(*, \"internals\")= num [1:88, 1:5] 0.0642 0.0423 0.045 0.0395 0.0498 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:5] \"Gi\" \"E(Gi)\" \"V(Gi)\" \"Z(Gi)\" ...\n - attr(*, \"cluster\")= Factor w/ 2 levels \"Low\",\"High\": 1 1 2 2 2 2 2 2 2 1 ...\n - attr(*, \"gstari\")= logi FALSE\n - attr(*, \"call\")= language localG(x = hunan$GDPPC, listw = wm62_lw)\n```\n:::\n:::\n\n\n**`gi.fixed`** is a numeric vector (or array) with some additional attributes. To access the Gi p-values, we can access the \"Pr(z != E(Gi))\" column using the attribute function **`attr()`**\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_value_fix <- attr(gi.fixed, \"internals\")[, \"Pr(z != E(Gi))\"]\n```\n:::\n\n\nAppend p-values to `hunan.gi`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan.gi <- cbind(hunan.gi, as.vector(p_value_fix)) %>% \n  rename(p_value_fix = as.vector.p_value_fix.)\n```\n:::\n\n\nPlot only significant Gi regions\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\nGimap_sig<-tm_shape(hunan.gi) +\n  tm_fill(col = \"p_value_fix\", \n          breaks = c(-Inf, 0.05, Inf),\n          palette = c('lightgreen', 'grey'),\n          title = \"local Gi p-values\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title= 'local Gi signif 95%')\n\ntmap_arrange(gdppc, Gimap, Gimap_sig,\n             asp=1,\n             nrow=2,\n             ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-68-1.png){width=1344}\n:::\n:::\n\n\n> The bottom left chart shows significant hot/cold spots at 95% confidence level. We can see that all of the coldspots are not statistically significant here.\n\n### **10.9.3 Gi statistics using adaptive distance**\n\nThe code chunk below are used to compute the Gi values for GDPPC2012 by using an adaptive distance weight matrix (i.e *`knn_lw`*).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfips <- order(hunan$County)\ngi.adaptive <- localG(hunan$GDPPC, knn_lw)\nhunan.gi <- cbind(hunan, as.matrix(gi.adaptive)) %>%\n  rename(gstat_adaptive = as.matrix.gi.adaptive.)\n```\n:::\n\n\n### **10.9.4 Mapping Gi values with adaptive distance weights**\n\nTo visualise the locations of hot spot and cold spot areas. The choropleth mapping functions of **tmap** package will be used to map the Gi values.\n\nThe code chunk below shows the functions used to map the Gi values derived using adaptive distance weight matrix.\n\n\n::: {.cell fig.asp='0.68'}\n\n```{.r .cell-code}\ngdppc<- qtm(hunan, \"GDPPC\") +\n    tm_layout(main.title= 'GDPPC')\n\nGimap <- tm_shape(hunan.gi) + \n  tm_fill(col = \"gstat_adaptive\", \n          style = \"pretty\", \n          palette=\"-RdBu\", \n          title = \"local Gi\") + \n  tm_borders(alpha = 0.5)+\n    tm_layout(main.title= 'local Gi (adaptive)')\n\ntmap_arrange(gdppc, \n             Gimap, \n             asp=1, \n             ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_2_files/figure-html/unnamed-chunk-70-1.png){width=1344}\n:::\n:::\n\n\n> From fixed-dist to adaptive-dist spatial weights matrix, the definition of neighbours and the way they interact with one another have changed, we can observe differences in identified cold/hot spots between the above chart and the one from the previous section.\n\n## 11 References\n\nTin Seong Kam. \"9 Global Measures of Spatial Autocorrelation\" From **R for Geospatial Data Science and Analytics** <https://r4gdsa.netlify.app/chap09>\n\nTin Seong Kam. \"10 Local Measures of Spatial Autocorrelation\" From **R for Geospatial Data Science and Analytics** <https://r4gdsa.netlify.app/chap10>\n\n## 12 Summary\n\n![]()![](images/Summary%20of%20deriving%20weights%20matrixv2-01.png)\n\n**Ways to check R object**\n\nclass(), methods(class=class(object_name)), str(), attributes(), spatial_weights_matrix\\$weights\n\n\n::: {.cell fig.asp='0.68'}\n\n:::\n",
    "supporting": [
      "Hands-on_Ex2_2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}